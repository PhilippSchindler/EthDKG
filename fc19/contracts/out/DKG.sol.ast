PragmaDirective
   Source: "pragma solidity ^0.4.24;"
ContractDefinition "DKG"
   Source: "contract DKG {\n\n    uint256 constant GROUP_ORDER   = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    uint256 constant FIELD_MODULUS = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    uint256 constant g1x = 1;\n    uint256 constant g1y = 2;\n\n    uint256 constant g2xx = 11559732032986387107991004021392285783925812861821192530917403151452391805634;\n    uint256 constant g2xy = 10857046999023057135944570762232829481370756359578518086990519993285655852781;\n    uint256 constant g2yx = 4082367875863433681332203403145435568316851327593401208105741076214120093531;\n    uint256 constant g2yy = 8495653923123431417604973247489272438418190587263600148770280649306958101930;\n\n    struct Node {\n        uint256 id;                 // the node's one based id, if id=0 the node has not registered or a dispute was successful\n        uint256 deposit;            \n        uint256[2] pk;              // the node's public key from group G1 (i.e. g1 * sk)\n        uint256[4] bls_pk;          // the node's public key from group G2 (i.e. g2 * sk)\n        bytes32 key_distribution_hash;\n    }\n\n    uint256[4] bls_group_pk;\n    address[] registered_addresses;\n    mapping (address => Node) nodes;\n\n    bool public aborted;       \n\n    uint256 public constant DELTA_INCLUDE = 10;\n    uint256 public constant DELTA_CONFIRM = 2;\n    uint256 public constant PARTICIPATION_THRESHOLD = 3;   // minimum number of nodes which need to register (inclusive)\n    // uint256 public constant PARTICIPATION_LIMIT = ???;  // maximum number of nodes allowed to register    (inclusive)\n\n    uint256 public T_CONTRACT_CREATION;     // block number in which the contract instance was created\n    uint256 public T_REGISTRATION_END;      // block number of the last block where registration is possible\n    uint256 public T_SHARING_END;           // block number of the last block where key sharing is possible\n    uint256 public T_DISPUTE_END;           // block number of the last block where dispute is possible.\n    uint256 public T_GROUP_KEY_UPLOAD;      // block number of the block in which the group key is uploaded (dynamic)\n    \n    event Registration(address node_adr, uint256 id, uint256 deposit, uint256[2] pk, uint256[4] bls_pk);\n    event KeySharing(uint256 issuer, uint256[] encrypted_shares, uint256[] public_coefficients);\n    event DisputeSuccessful(address bad_issuer_addr);\n\n    constructor() public {\n        T_CONTRACT_CREATION = block.number;\n        T_REGISTRATION_END = T_CONTRACT_CREATION + DELTA_CONFIRM + DELTA_INCLUDE;\n        T_SHARING_END = T_REGISTRATION_END + DELTA_CONFIRM + DELTA_INCLUDE;\n        T_DISPUTE_END = T_SHARING_END + DELTA_CONFIRM + DELTA_INCLUDE;\n    }\n\n    function in_registration_phase() \n    public view returns(bool) {\n        return block.number <= T_REGISTRATION_END;\n    }\n\n    function in_sharing_phase() \n    public view returns(bool) {\n        return (T_REGISTRATION_END < block.number) && (block.number <= T_SHARING_END);\n    }\n\n    function in_dispute_phase() \n    public view returns(bool) {\n        return (T_SHARING_END < block.number) && (block.number <= T_DISPUTE_END);\n    }\n\n    function in_finalization_phase()\n    public view returns(bool) {\n        return (T_DISPUTE_END < block.number) && (T_GROUP_KEY_UPLOAD == 0);\n    }\n\n    function registrations_confirmed() \n    public view returns(bool) {\n        return T_REGISTRATION_END + DELTA_CONFIRM <= block.number;\n    }\n\n    function sharing_confirmed()\n    public view returns(bool) {\n        return T_SHARING_END + DELTA_CONFIRM <= block.number;\n    }\n\n    function dispute_confirmed()\n    public view returns(bool) {\n        return T_DISPUTE_END + DELTA_CONFIRM <= block.number;\n    }\n\n    function group_key_confirmed()\n    public view returns(bool) {\n        return (T_GROUP_KEY_UPLOAD != 0) && (T_GROUP_KEY_UPLOAD + DELTA_CONFIRM <= block.number);\n    }\n\n\n    function register(uint256[2] pk, uint256[4] bls_pk, uint256[2] sk_knowledge_proof) \n    public payable \n    {\n        require(in_registration_phase(), \"registration failed (contract is not in registration phase)\");\n        require(nodes[msg.sender].id == 0, \"registration failed (account already registered a public key)\");\n        require(\n            bn128_check_pairing(                                    // ensures that the given pk and bls_pk correspond to each other\n                [                                                   // i.e. that pk and bls_pk are of the form\n                    pk[0], pk[1],                                   // pk     =  g1 * sk\n                    g2xx, g2xy, g2yx, g2yy,                         // bls_pk = -g2 * sk\n                    g1x, g1y,                                       // for some secret key sk\n                    bls_pk[0], bls_pk[1], bls_pk[2], bls_pk[3]\n                ]), \n            \"registration failed (bls public key is invalid)\"\n        );\n        require(\n            verify_sk_knowledge(pk, sk_knowledge_proof), \n            \"registration failed (invalid proof of secret key knowlegde)\"\n        );\n\n        // TODO: check deposit\n\n        registered_addresses.push(msg.sender);\n        uint256 id = registered_addresses.length;        \n\n        nodes[msg.sender].id = id;\n        nodes[msg.sender].deposit = msg.value;\n        nodes[msg.sender].pk[0] = pk[0];\n        nodes[msg.sender].pk[1] = pk[1];\n        nodes[msg.sender].bls_pk[0] = bls_pk[0];\n        nodes[msg.sender].bls_pk[1] = bls_pk[1];\n        nodes[msg.sender].bls_pk[2] = bls_pk[2];\n        nodes[msg.sender].bls_pk[3] = bls_pk[3];\n\n        emit Registration(msg.sender, id, msg.value, pk, bls_pk);\n    }\n\n    function share_key(\n        uint256[] encrypted_shares,     // Enc_kAB(s_i), each 256 bit\n        uint256[] public_coefficients)  // Cj, each 512 bit\n    public\n    {\n        uint256 n = registered_addresses.length;\n        uint256 t = (n / 2) + 1;\n        uint256 issuer_id = nodes[msg.sender].id;\n\n        require(in_sharing_phase(), \"key sharing failed (contract is not in sharing phase)\");\n        require(issuer_id > 0, \"key sharing failed (ethereum account has not registered)\");\n        require(encrypted_shares.length == n - 1, \"key sharing failed (invalid number of encrypted shares provided)\");\n        require(public_coefficients.length == t * 2 - 2, \"key sharing failed (invalid number of commitments provided)\");\n\n        // for optimization we only store the hash of the submitted data\n        // and emit an event with the actual data\n        nodes[msg.sender].key_distribution_hash = keccak256(abi.encodePacked(encrypted_shares, public_coefficients));\n        emit KeySharing(issuer_id, encrypted_shares, public_coefficients);\n    }\n\n    function dispute_public_coefficient(\n        address issuer_addr,             // the node which is accussed to have distributed (at least one) invalid coefficient\n        uint256[] encrypted_shares,      // the data from previous KeySharing event\n        uint256[] public_coefficients,   // the data from previous KeySharing event\n        uint256 invalid_coefficient_idx  // specifies any coefficient which is invalid (used for efficiency)\n    ) \n    public\n    {\n        Node storage issuer = nodes[issuer_addr];\n        Node storage verifier = nodes[msg.sender];\n\n        require(in_dispute_phase(), \"dispute failed (contract is not in sharing phase)\");\n        require(issuer.id > 0, \"dispute failed/aborted (issuer not registered or slashed)\");\n        require(verifier.id > 0, \"dispute failed/aborted (verifier not registered or slashed)\");\n        require(issuer.id != verifier.id, \"dispute failed (self dispute is not allowed)\");\n        require(\n            issuer.key_distribution_hash == keccak256(abi.encodePacked(encrypted_shares, public_coefficients)),\n            \"dispute failed (encrypted shares and/or public coefficients not matching)\"\n        );\n\n        uint256 i = invalid_coefficient_idx * 2;\n        require(\n            !bn128_is_on_curve([public_coefficients[i], public_coefficients[i + 1]]),\n            \"dispute failed (coefficient is actually valid)\"\n        );\n\n        __slash__(issuer_addr);\n    }\n\n    function dispute_share(\n        address issuer_addr,             // the node which is accussed to have distributed an invalid share\n        uint256[] encrypted_shares,      // the data from previous KeyDistribution event\n        uint256[] public_coefficients,   // the data from previous KeyDistribution event\n        uint256[2] decryption_key,       // shared key between issuer and calling node\n        uint256[2] decryption_key_proof) // NIZK proof, showing that decryption key is valid\n    public\n    {\n        Node storage issuer = nodes[issuer_addr];\n        Node storage verifier = nodes[msg.sender];\n\n        require(in_dispute_phase(), \"dispute failed (contract is not in sharing phase)\");\n        require(issuer.id > 0, \"dispute failed/aborted (issuer not registered or slashed)\");\n        require(verifier.id > 0, \"dispute failed/aborted (verifier not registered or slashed)\");\n        require(issuer.id != verifier.id, \"dispute failed (self dispute is not allowed)\");\n        require(\n            issuer.key_distribution_hash == keccak256(abi.encodePacked(encrypted_shares, public_coefficients)),\n            \"dispute failed (encrypted shares and/or public coefficients not matching)\"\n        );\n        require(\n            verify_decryption_key(decryption_key, decryption_key_proof, verifier.pk, issuer.pk),\n            \"dispute failed (invalid decryption key or decryption key proof)\"\n        );\n\n        // compute share index i:\n        // the index i is one-based (which is required!) (indepent of the correction below)\n        // as the issuer does not provide a share for itself the index has to be corrected\n        uint256 i = verifier.id;\n        if (i > issuer.id) {\n            i--;\n        }\n\n        // decryption of the share, (correct for one-based index i to make it zero-based)\n        uint256 share = encrypted_shares[i - 1] ^ uint256(keccak256(abi.encodePacked(decryption_key[0], verifier.id)));\n        // require(false, \"test assert here\");\n        \n        // verify that share is actually invalid\n        // evaluate the poly polynom F(x) for x = i\n        uint256 x = i;\n        uint256[2] memory Fx = [ issuer.pk[0], issuer.pk[1] ];\n        uint256[2] memory tmp = bn128_multiply([public_coefficients[0], public_coefficients[1], x]);\n        Fx = bn128_add([Fx[0], Fx[1], tmp[0], tmp[1]]);\n\n        for (uint256 j = 2; j < public_coefficients.length; j += 2) { \n            x = mulmod(x, i, GROUP_ORDER);\n            tmp = bn128_multiply([public_coefficients[j], public_coefficients[j + 1], x]);\n            Fx = bn128_add([Fx[0], Fx[1], tmp[0], tmp[1]]);\n        }\n        // and compare the result (stored in Fx) with g1*si\n        uint256[2] memory Fi = bn128_multiply([g1x, g1y, share]);   \n\n        // require that share is actually invalid\n        require(Fx[0] != Fi[0] || Fx[1] != Fi[1], \"dispute failed (the provided share was valid)\");\n\n        __slash__(issuer_addr);\n    }\n\n    // compute the group key in the elliptic curve group G1\n    // and verify the uploaded bls_group_pk from G2 with the pairing\n    // only non-successfully-disputed keys form the group keys\n    // calls abort if insufficient valid keys have been registered\n    function upload_group_key(uint[4] _bls_group_pk) \n    public returns(bool success)\n    {\n        require(\n            in_finalization_phase(),    \n            \"group key upload failed (key sharing / disputes not finsished, or group key already uploaded)\"\n        );\n\n        uint256 n = registered_addresses.length;\n        uint256 t = (n / 2) + 1;\n        \n        Node memory node;\n        uint256[2] memory group_pk;\n        \n        // find first (i.e. lowest index) valid registered node\n        uint256 i = 0;\n        do {\n            node = nodes[registered_addresses[i]];\n            i += 1;\n        } \n        while((node.id == 0 || node.key_distribution_hash == 0) && i < n);\n\n        if (i == n) {\n            // in this case at most one nodes actually shared a valid key\n            __abort__();\n            return false;\n        }\n        \n        uint256 p = 1;  // number of nodes which provided valid keys\n        group_pk = node.pk;\n        for ( ; i < registered_addresses.length; i++) {  // sum up all valid pubic keys\n            node = nodes[registered_addresses[i]];\n            if (node.id != 0 && node.key_distribution_hash != 0) {\n                p++;\n                group_pk = bn128_add([group_pk[0], group_pk[1], node.pk[0], node.pk[1]]);\n            }\n        }\n\n        if (p < t) {\n            __abort__();\n            return false;\n        }\n\n        // ensures that the given group_pk and bls_group_pk correspond to each other\n        require(\n            bn128_check_pairing(                                    \n                [                       \n                    group_pk[0], group_pk[1],\n                    g2xx, g2xy, g2yx, g2yy,\n                    g1x, g1y,\n                    _bls_group_pk[0], _bls_group_pk[1], _bls_group_pk[2], _bls_group_pk[3]\n                ]), \n            \"upload of group key failed (the submitted bls_group_pk does not correspond to group_pk)\"\n        );\n\n        bls_group_pk = _bls_group_pk;\n        T_GROUP_KEY_UPLOAD = block.number;\n    }\n\n    function __slash__(address addr) \n    private \n    {\n        emit DisputeSuccessful(addr);\n        nodes[addr].id = 0;\n    }\n\n    // checks abort condition and aborts the contract if at least one abort condition is fulfilled\n    function abort() \n    public \n    {\n        // never abort during registration phase\n        require(!in_registration_phase(), \"abort failed (cannot abort during registration phase)\");\n\n        uint256 n = registered_addresses.length;\n        uint256 t = (n / 2) + 1;\n\n        // abort is possible if not enough nodes joined the DKG protocol\n        if (n < PARTICIPATION_THRESHOLD) {\n            __abort__();\n        }\n\n        // abort is possible if less then t nodes actually shared their keys without disputes\n        else {\n            require(\n                T_SHARING_END < block.number, \n                \"abort failed (abort is only possible after key sharing phase ended)\"\n            );\n            uint256 p = 0;  // number of nodes with shared their key without disputes\n            for (uint256 i = 0; i < n; i++) {\n                Node memory node = nodes[registered_addresses[i]];\n\n                // id != 0 ensures not was not slashed\n                // hashkey_distribution_hash != 0 ensures that node has shared its key\n                if ((node.id != 0) && node.key_distribution_hash != 0)  {\n                    p++;\n                }                \n            }\n            require(\n                p < t,\n                \"abort failed (abort is only possible if less than t nodes shared their key successfully)\"\n            );\n            __abort__();\n        }\n    }\n\n    // aborts the contract and releases all the deposits to be withdrawn from the contract\n    // slashed deposists are evenly distributed to all other nodes\n    function __abort__() \n    private \n    {\n        // TODO\n        aborted = true;\n    }\n\n\n    // verifies that the sender account knows the private key corresponding to the given public key\n    function verify_sk_knowledge(uint[2] public_key, uint[2] proof) \n    public returns (bool)\n    {\n        uint256[2] memory a = bn128_multiply([g1x, g1y, proof[1]]);\n        uint256[2] memory b = bn128_multiply([public_key[0], public_key[1], proof[0]]);\n        uint256[2] memory t = bn128_add([a[0], a[1], b[0], b[1]]);\n        \n        uint256 c = uint256(\n            keccak256(abi.encodePacked(g1x, g1y, public_key[0], public_key[1], t[0], t[1], msg.sender)));\n\n        return proof[0] == c;\n    }\n\n\n    // implement the verification procedure for the NIZK DLEQ (discrete logarithm equalty) proof\n    function verify_decryption_key(\n        uint256[2] decryption_key, \n        uint256[2] correctness_proof, // DLEQ challenge and response      \n        uint256[2] verifier_pk,\n        uint256[2] issuer_pk) \n    public returns (bool key_valid)\n    {\n        // equivalent to DLEQ_verify(G1, issuer_pk, verifier_pk, decryption_key, correctness_proof) in python\n\n        uint256[2] memory tmp1;  // two temporary variables\n        uint256[2] memory tmp2;\n\n        tmp1 = bn128_multiply([g1x, g1y, correctness_proof[1]]);\n        tmp2 = bn128_multiply([verifier_pk[0], verifier_pk[1], correctness_proof[0]]);\n        uint256[2] memory a1 = bn128_add([tmp1[0], tmp1[1], tmp2[0], tmp2[1]]);\n        \n        tmp1 = bn128_multiply([issuer_pk[0], issuer_pk[1], correctness_proof[1]]);\n        tmp2 = bn128_multiply([decryption_key[0], decryption_key[1], correctness_proof[0]]);\n        uint256[2] memory a2 = bn128_add([tmp1[0], tmp1[1], tmp2[0], tmp2[1]]);\n\n        uint256 challenge_computed = uint256(\n            keccak256(abi.encodePacked(a1, a2, g1x, g1y, verifier_pk, issuer_pk, decryption_key)));\n\n        key_valid = correctness_proof[0] == challenge_computed;\n    }\n\n    function verify_signature(uint256[4] bls_pk, bytes32 message, uint256[2] signature) \n    public returns (bool signature_valid)\n    {\n        uint[2] memory h = bn128_map_to_G1(message);\n        signature_valid = bn128_check_pairing(                                   \n            [                                                  \n                signature[0], signature[1],                                  \n                g2xx, g2xy, g2yx, g2yy,                        \n                h[0], h[1],                                      \n                bls_pk[0], bls_pk[1], bls_pk[2], bls_pk[3]\n            ]);\n    }\n    \n    function bn128_add(uint256[4] input) \n    public returns (uint256[2] result) {\n        // computes P + Q \n        // input: 4 values of 256 bit each\n        //  *) x-coordinate of point P\n        //  *) y-coordinate of point P\n        //  *) x-coordinate of point Q\n        //  *) y-coordinate of point Q\n\n        bool success;\n        assembly {\n            // 0x06     id of precompiled bn256Add contract\n            // 0        number of ether to transfer\n            // 128      size of call parameters, i.e. 128 bytes total\n            // 64       size of call return value, i.e. 64 bytes / 512 bit for a BN256 curve point\n            success := call(not(0), 0x06, 0, input, 128, result, 64)\n        }\n        require(success, \"elliptic curve addition failed\");\n    }\n\n    function bn128_multiply(uint256[3] input) \n    public returns (uint256[2] result) {\n        // computes P*x \n        // input: 3 values of 256 bit each\n        //  *) x-coordinate of point P\n        //  *) y-coordinate of point P\n        //  *) scalar x\n\n        bool success;\n        assembly {\n            // 0x07     id of precompiled bn256ScalarMul contract\n            // 0        number of ether to transfer\n            // 96       size of call parameters, i.e. 96 bytes total (256 bit for x, 256 bit for y, 256 bit for scalar)\n            // 64       size of call return value, i.e. 64 bytes / 512 bit for a BN256 curve point\n            success := call(not(0), 0x07, 0, input, 96, result, 64)\n        }\n        require(success, \"elliptic curve multiplication failed\");\n    }\n\n    function bn128_is_on_curve(uint[2] point) \n    public returns(bool valid) {\n        // checks if the given point is a valid point from the first elliptic curve group\n        // by trying an addition with the generator point g1\n        uint256[4] memory input = [point[0], point[1], g1x, g1y];\n        assembly {\n            // 0x06     id of precompiled bn256Add contract\n            // 0        number of ether to transfer\n            // 128      size of call parameters, i.e. 128 bytes total\n            // 64       size of call return value, i.e. 64 bytes / 512 bit for a BN256 curve point\n            valid := call(not(0), 0x06, 0, input, 128, input, 64)\n        }\n    }\n\n    function bn128_check_pairing(uint256[12] input) \n    public returns (bool) {\n        uint256[1] memory result;\n        bool success;\n        assembly {\n            // 0x08     id of precompiled bn256Pairing contract     (checking the elliptic curve pairings)\n            // 0        number of ether to transfer\n            // 384       size of call parameters, i.e. 12*256 bits == 384 bytes\n            // 32        size of result (one 32 byte boolean!)\n            success := call(sub(gas, 2000), 0x08, 0, input, 384, result, 32)\n        }\n        require(success, \"elliptic curve pairing failed\");\n        return result[0] == 1;\n    }\n\n\n    function bn128_map_to_G1(bytes32 data)\n    public returns (uint[2] point) \n    {\n        uint256 ctr = 0;\n        while (true) {\n            uint256 x = uint256(keccak256(abi.encodePacked(ctr, data)));\n            bool b = x & 1 == 1;    // extract last bit of the hash\n            x >>= 2;                // drop last 2 bits of the hash, a coordinate is a 254 bit number\n\n            if (x < FIELD_MODULUS) { \n                // p...  FIELD_MODULUS\n                // z = x**3 + 3 (mod p)\n                uint256 z = (bigModExp([32, 32, 32, x, 3, FIELD_MODULUS]) + 3) % FIELD_MODULUS; \n\n                // y = sqrt(z) = z**((p + 1) / 4) mod p\n                uint256 y = bigModExp([32, 32, 32, z, (FIELD_MODULUS + 1) >> 2, FIELD_MODULUS]);\n\n                // checks if y is indeed a square root of z mod p\n                if (bigModExp([32, 32, 32, y, 2, FIELD_MODULUS]) == z) {\n                    if (b) {\n                        y = (FIELD_MODULUS - y);\n                    }\n                    return [x, y]; \n                }\n            }\n            ctr++;\n        }    \n    }\n\n    \n    function bigModExp(uint256[6] input) \n    public returns (uint256) {\n        // call the precompiled contract to compute the b^e mod m\n        // used the following arguments in the given order\n        //  - length of the base b\n        //  - length of the exponent e\n        //  - length of the modulus m\n        //  - the base b itself\n        //  - the exponent e itself\n        //  - the modulus m itself\n        // we use 256 bit integers for all of the above values\n\n        bool success;\n        uint256[1] memory result;\n        assembly {\n            // 0x05     id of precompiled bigModExp contract\n            // 0        number of ether to transfer\n            // 192      size of call parameters, i.e. 192 bytes total (6x 256 bit)\n            // 32       size of call return value, i.e. 32 bytes / 256 bit\n            success := call(not(0), 0x05, 0, input, 192, result, 32)\n        }\n        require(success, \"bigModExp operation failed\");\n        return result[0];\n    }\n\n}"
  VariableDeclaration "GROUP_ORDER"
     Type: uint256
     Source: "uint256 constant GROUP_ORDER   = 21888242871839275222246405745257275088548364400416034343698204186575808495617"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 21888242871839275222246405745257275088548364400416034343698204186575808495617
       Type: int_const 2188...(69 digits omitted)...5617
       Source: "21888242871839275222246405745257275088548364400416034343698204186575808495617"
  VariableDeclaration "FIELD_MODULUS"
     Type: uint256
     Source: "uint256 constant FIELD_MODULUS = 21888242871839275222246405745257275088696311157297823662689037894645226208583"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 21888242871839275222246405745257275088696311157297823662689037894645226208583
       Type: int_const 2188...(69 digits omitted)...8583
       Source: "21888242871839275222246405745257275088696311157297823662689037894645226208583"
  VariableDeclaration "g1x"
     Type: uint256
     Source: "uint256 constant g1x = 1"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 1
       Type: int_const 1
       Source: "1"
  VariableDeclaration "g1y"
     Type: uint256
     Source: "uint256 constant g1y = 2"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 2
       Type: int_const 2
       Source: "2"
  VariableDeclaration "g2xx"
     Type: uint256
     Source: "uint256 constant g2xx = 11559732032986387107991004021392285783925812861821192530917403151452391805634"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 11559732032986387107991004021392285783925812861821192530917403151452391805634
       Type: int_const 1155...(69 digits omitted)...5634
       Source: "11559732032986387107991004021392285783925812861821192530917403151452391805634"
  VariableDeclaration "g2xy"
     Type: uint256
     Source: "uint256 constant g2xy = 10857046999023057135944570762232829481370756359578518086990519993285655852781"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 10857046999023057135944570762232829481370756359578518086990519993285655852781
       Type: int_const 1085...(69 digits omitted)...2781
       Source: "10857046999023057135944570762232829481370756359578518086990519993285655852781"
  VariableDeclaration "g2yx"
     Type: uint256
     Source: "uint256 constant g2yx = 4082367875863433681332203403145435568316851327593401208105741076214120093531"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 4082367875863433681332203403145435568316851327593401208105741076214120093531
       Type: int_const 4082...(68 digits omitted)...3531
       Source: "4082367875863433681332203403145435568316851327593401208105741076214120093531"
  VariableDeclaration "g2yy"
     Type: uint256
     Source: "uint256 constant g2yy = 8495653923123431417604973247489272438418190587263600148770280649306958101930"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 8495653923123431417604973247489272438418190587263600148770280649306958101930
       Type: int_const 8495...(68 digits omitted)...1930
       Source: "8495653923123431417604973247489272438418190587263600148770280649306958101930"
  StructDefinition "Node"
     Source: "struct Node {\n        uint256 id;                 // the node's one based id, if id=0 the node has not registered or a dispute was successful\n        uint256 deposit;            \n        uint256[2] pk;              // the node's public key from group G1 (i.e. g1 * sk)\n        uint256[4] bls_pk;          // the node's public key from group G2 (i.e. g2 * sk)\n        bytes32 key_distribution_hash;\n    }"
    VariableDeclaration "id"
       Type: uint256
       Source: "uint256 id"
      ElementaryTypeName uint256
         Source: "uint256"
    VariableDeclaration "deposit"
       Type: uint256
       Source: "uint256 deposit"
      ElementaryTypeName uint256
         Source: "uint256"
    VariableDeclaration "pk"
       Type: uint256[2] storage pointer
       Source: "uint256[2] pk"
      ArrayTypeName
         Source: "uint256[2]"
        ElementaryTypeName uint256
           Source: "uint256"
        Literal, token: [no token] value: 2
           Type unknown.
           Source: "2"
    VariableDeclaration "bls_pk"
       Type: uint256[4] storage pointer
       Source: "uint256[4] bls_pk"
      ArrayTypeName
         Source: "uint256[4]"
        ElementaryTypeName uint256
           Source: "uint256"
        Literal, token: [no token] value: 4
           Type unknown.
           Source: "4"
    VariableDeclaration "key_distribution_hash"
       Type: bytes32
       Source: "bytes32 key_distribution_hash"
      ElementaryTypeName bytes32
         Source: "bytes32"
  VariableDeclaration "bls_group_pk"
     Type: uint256[4] storage ref
     Source: "uint256[4] bls_group_pk"
    ArrayTypeName
       Source: "uint256[4]"
      ElementaryTypeName uint256
         Source: "uint256"
      Literal, token: [no token] value: 4
         Type unknown.
         Source: "4"
  VariableDeclaration "registered_addresses"
     Type: address[] storage ref
     Source: "address[] registered_addresses"
    ArrayTypeName
       Source: "address[]"
      ElementaryTypeName address
         Source: "address"
  VariableDeclaration "nodes"
     Type: mapping(address => struct DKG.Node storage ref)
     Source: "mapping (address => Node) nodes"
    Mapping
       Source: "mapping (address => Node)"
      ElementaryTypeName address
         Source: "address"
      UserDefinedTypeName "Node"
         Source: "Node"
  VariableDeclaration "aborted"
     Type: bool
     Source: "bool public aborted"
    ElementaryTypeName bool
       Source: "bool"
  VariableDeclaration "DELTA_INCLUDE"
     Type: uint256
     Source: "uint256 public constant DELTA_INCLUDE = 10"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 10
       Type: int_const 10
       Source: "10"
  VariableDeclaration "DELTA_CONFIRM"
     Type: uint256
     Source: "uint256 public constant DELTA_CONFIRM = 2"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 2
       Type: int_const 2
       Source: "2"
  VariableDeclaration "PARTICIPATION_THRESHOLD"
     Type: uint256
     Source: "uint256 public constant PARTICIPATION_THRESHOLD = 3"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 3
       Type: int_const 3
       Source: "3"
  VariableDeclaration "T_CONTRACT_CREATION"
     Type: uint256
     Source: "uint256 public T_CONTRACT_CREATION"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "T_REGISTRATION_END"
     Type: uint256
     Source: "uint256 public T_REGISTRATION_END"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "T_SHARING_END"
     Type: uint256
     Source: "uint256 public T_SHARING_END"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "T_DISPUTE_END"
     Type: uint256
     Source: "uint256 public T_DISPUTE_END"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "T_GROUP_KEY_UPLOAD"
     Type: uint256
     Source: "uint256 public T_GROUP_KEY_UPLOAD"
    ElementaryTypeName uint256
       Source: "uint256"
  EventDefinition "Registration"
     Source: "event Registration(address node_adr, uint256 id, uint256 deposit, uint256[2] pk, uint256[4] bls_pk);"
    ParameterList
       Source: "(address node_adr, uint256 id, uint256 deposit, uint256[2] pk, uint256[4] bls_pk)"
      VariableDeclaration "node_adr"
         Type: address
         Source: "address node_adr"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "id"
         Type: uint256
         Source: "uint256 id"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "deposit"
         Type: uint256
         Source: "uint256 deposit"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "pk"
         Type: uint256[2] memory
         Source: "uint256[2] pk"
        ArrayTypeName
           Source: "uint256[2]"
          ElementaryTypeName uint256
             Source: "uint256"
          Literal, token: [no token] value: 2
             Type unknown.
             Source: "2"
      VariableDeclaration "bls_pk"
         Type: uint256[4] memory
         Source: "uint256[4] bls_pk"
        ArrayTypeName
           Source: "uint256[4]"
          ElementaryTypeName uint256
             Source: "uint256"
          Literal, token: [no token] value: 4
             Type unknown.
             Source: "4"
  EventDefinition "KeySharing"
     Source: "event KeySharing(uint256 issuer, uint256[] encrypted_shares, uint256[] public_coefficients);"
    ParameterList
       Source: "(uint256 issuer, uint256[] encrypted_shares, uint256[] public_coefficients)"
      VariableDeclaration "issuer"
         Type: uint256
         Source: "uint256 issuer"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "encrypted_shares"
         Type: uint256[] memory
         Source: "uint256[] encrypted_shares"
        ArrayTypeName
           Source: "uint256[]"
          ElementaryTypeName uint256
             Source: "uint256"
      VariableDeclaration "public_coefficients"
         Type: uint256[] memory
         Source: "uint256[] public_coefficients"
        ArrayTypeName
           Source: "uint256[]"
          ElementaryTypeName uint256
             Source: "uint256"
  EventDefinition "DisputeSuccessful"
     Source: "event DisputeSuccessful(address bad_issuer_addr);"
    ParameterList
       Source: "(address bad_issuer_addr)"
      VariableDeclaration "bad_issuer_addr"
         Type: address
         Source: "address bad_issuer_addr"
        ElementaryTypeName address
           Source: "address"
  FunctionDefinition "" - public
     Source: "constructor() public {\n        T_CONTRACT_CREATION = block.number;\n        T_REGISTRATION_END = T_CONTRACT_CREATION + DELTA_CONFIRM + DELTA_INCLUDE;\n        T_SHARING_END = T_REGISTRATION_END + DELTA_CONFIRM + DELTA_INCLUDE;\n        T_DISPUTE_END = T_SHARING_END + DELTA_CONFIRM + DELTA_INCLUDE;\n    }"
    ParameterList
       Source: "()"
    ParameterList
       Source: ""
    Block
       Source: "{\n        T_CONTRACT_CREATION = block.number;\n        T_REGISTRATION_END = T_CONTRACT_CREATION + DELTA_CONFIRM + DELTA_INCLUDE;\n        T_SHARING_END = T_REGISTRATION_END + DELTA_CONFIRM + DELTA_INCLUDE;\n        T_DISPUTE_END = T_SHARING_END + DELTA_CONFIRM + DELTA_INCLUDE;\n    }"
      ExpressionStatement
         Source: "T_CONTRACT_CREATION = block.number"
        Assignment using operator =
           Type: uint256
           Source: "T_CONTRACT_CREATION = block.number"
          Identifier T_CONTRACT_CREATION
             Type: uint256
             Source: "T_CONTRACT_CREATION"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
      ExpressionStatement
         Source: "T_REGISTRATION_END = T_CONTRACT_CREATION + DELTA_CONFIRM + DELTA_INCLUDE"
        Assignment using operator =
           Type: uint256
           Source: "T_REGISTRATION_END = T_CONTRACT_CREATION + DELTA_CONFIRM + DELTA_INCLUDE"
          Identifier T_REGISTRATION_END
             Type: uint256
             Source: "T_REGISTRATION_END"
          BinaryOperation using operator +
             Type: uint256
             Source: "T_CONTRACT_CREATION + DELTA_CONFIRM + DELTA_INCLUDE"
            BinaryOperation using operator +
               Type: uint256
               Source: "T_CONTRACT_CREATION + DELTA_CONFIRM"
              Identifier T_CONTRACT_CREATION
                 Type: uint256
                 Source: "T_CONTRACT_CREATION"
              Identifier DELTA_CONFIRM
                 Type: uint256
                 Source: "DELTA_CONFIRM"
            Identifier DELTA_INCLUDE
               Type: uint256
               Source: "DELTA_INCLUDE"
      ExpressionStatement
         Source: "T_SHARING_END = T_REGISTRATION_END + DELTA_CONFIRM + DELTA_INCLUDE"
        Assignment using operator =
           Type: uint256
           Source: "T_SHARING_END = T_REGISTRATION_END + DELTA_CONFIRM + DELTA_INCLUDE"
          Identifier T_SHARING_END
             Type: uint256
             Source: "T_SHARING_END"
          BinaryOperation using operator +
             Type: uint256
             Source: "T_REGISTRATION_END + DELTA_CONFIRM + DELTA_INCLUDE"
            BinaryOperation using operator +
               Type: uint256
               Source: "T_REGISTRATION_END + DELTA_CONFIRM"
              Identifier T_REGISTRATION_END
                 Type: uint256
                 Source: "T_REGISTRATION_END"
              Identifier DELTA_CONFIRM
                 Type: uint256
                 Source: "DELTA_CONFIRM"
            Identifier DELTA_INCLUDE
               Type: uint256
               Source: "DELTA_INCLUDE"
      ExpressionStatement
         Source: "T_DISPUTE_END = T_SHARING_END + DELTA_CONFIRM + DELTA_INCLUDE"
        Assignment using operator =
           Type: uint256
           Source: "T_DISPUTE_END = T_SHARING_END + DELTA_CONFIRM + DELTA_INCLUDE"
          Identifier T_DISPUTE_END
             Type: uint256
             Source: "T_DISPUTE_END"
          BinaryOperation using operator +
             Type: uint256
             Source: "T_SHARING_END + DELTA_CONFIRM + DELTA_INCLUDE"
            BinaryOperation using operator +
               Type: uint256
               Source: "T_SHARING_END + DELTA_CONFIRM"
              Identifier T_SHARING_END
                 Type: uint256
                 Source: "T_SHARING_END"
              Identifier DELTA_CONFIRM
                 Type: uint256
                 Source: "DELTA_CONFIRM"
            Identifier DELTA_INCLUDE
               Type: uint256
               Source: "DELTA_INCLUDE"
  FunctionDefinition "in_registration_phase" - public - const
     Source: "function in_registration_phase() \n    public view returns(bool) {\n        return block.number <= T_REGISTRATION_END;\n    }"
    ParameterList
       Source: "()"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\n        return block.number <= T_REGISTRATION_END;\n    }"
      Return
         Source: "return block.number <= T_REGISTRATION_END"
        BinaryOperation using operator <=
           Type: bool
           Source: "block.number <= T_REGISTRATION_END"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
          Identifier T_REGISTRATION_END
             Type: uint256
             Source: "T_REGISTRATION_END"
  FunctionDefinition "in_sharing_phase" - public - const
     Source: "function in_sharing_phase() \n    public view returns(bool) {\n        return (T_REGISTRATION_END < block.number) && (block.number <= T_SHARING_END);\n    }"
    ParameterList
       Source: "()"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\n        return (T_REGISTRATION_END < block.number) && (block.number <= T_SHARING_END);\n    }"
      Return
         Source: "return (T_REGISTRATION_END < block.number) && (block.number <= T_SHARING_END)"
        BinaryOperation using operator &&
           Type: bool
           Source: "(T_REGISTRATION_END < block.number) && (block.number <= T_SHARING_END)"
          TupleExpression
             Type: bool
             Source: "(T_REGISTRATION_END < block.number)"
            BinaryOperation using operator <
               Type: bool
               Source: "T_REGISTRATION_END < block.number"
              Identifier T_REGISTRATION_END
                 Type: uint256
                 Source: "T_REGISTRATION_END"
              MemberAccess to member number
                 Type: uint256
                 Source: "block.number"
                Identifier block
                   Type: block
                   Source: "block"
          TupleExpression
             Type: bool
             Source: "(block.number <= T_SHARING_END)"
            BinaryOperation using operator <=
               Type: bool
               Source: "block.number <= T_SHARING_END"
              MemberAccess to member number
                 Type: uint256
                 Source: "block.number"
                Identifier block
                   Type: block
                   Source: "block"
              Identifier T_SHARING_END
                 Type: uint256
                 Source: "T_SHARING_END"
  FunctionDefinition "in_dispute_phase" - public - const
     Source: "function in_dispute_phase() \n    public view returns(bool) {\n        return (T_SHARING_END < block.number) && (block.number <= T_DISPUTE_END);\n    }"
    ParameterList
       Source: "()"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\n        return (T_SHARING_END < block.number) && (block.number <= T_DISPUTE_END);\n    }"
      Return
         Source: "return (T_SHARING_END < block.number) && (block.number <= T_DISPUTE_END)"
        BinaryOperation using operator &&
           Type: bool
           Source: "(T_SHARING_END < block.number) && (block.number <= T_DISPUTE_END)"
          TupleExpression
             Type: bool
             Source: "(T_SHARING_END < block.number)"
            BinaryOperation using operator <
               Type: bool
               Source: "T_SHARING_END < block.number"
              Identifier T_SHARING_END
                 Type: uint256
                 Source: "T_SHARING_END"
              MemberAccess to member number
                 Type: uint256
                 Source: "block.number"
                Identifier block
                   Type: block
                   Source: "block"
          TupleExpression
             Type: bool
             Source: "(block.number <= T_DISPUTE_END)"
            BinaryOperation using operator <=
               Type: bool
               Source: "block.number <= T_DISPUTE_END"
              MemberAccess to member number
                 Type: uint256
                 Source: "block.number"
                Identifier block
                   Type: block
                   Source: "block"
              Identifier T_DISPUTE_END
                 Type: uint256
                 Source: "T_DISPUTE_END"
  FunctionDefinition "in_finalization_phase" - public - const
     Source: "function in_finalization_phase()\n    public view returns(bool) {\n        return (T_DISPUTE_END < block.number) && (T_GROUP_KEY_UPLOAD == 0);\n    }"
    ParameterList
       Source: "()"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\n        return (T_DISPUTE_END < block.number) && (T_GROUP_KEY_UPLOAD == 0);\n    }"
      Return
         Source: "return (T_DISPUTE_END < block.number) && (T_GROUP_KEY_UPLOAD == 0)"
        BinaryOperation using operator &&
           Type: bool
           Source: "(T_DISPUTE_END < block.number) && (T_GROUP_KEY_UPLOAD == 0)"
          TupleExpression
             Type: bool
             Source: "(T_DISPUTE_END < block.number)"
            BinaryOperation using operator <
               Type: bool
               Source: "T_DISPUTE_END < block.number"
              Identifier T_DISPUTE_END
                 Type: uint256
                 Source: "T_DISPUTE_END"
              MemberAccess to member number
                 Type: uint256
                 Source: "block.number"
                Identifier block
                   Type: block
                   Source: "block"
          TupleExpression
             Type: bool
             Source: "(T_GROUP_KEY_UPLOAD == 0)"
            BinaryOperation using operator ==
               Type: bool
               Source: "T_GROUP_KEY_UPLOAD == 0"
              Identifier T_GROUP_KEY_UPLOAD
                 Type: uint256
                 Source: "T_GROUP_KEY_UPLOAD"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
  FunctionDefinition "registrations_confirmed" - public - const
     Source: "function registrations_confirmed() \n    public view returns(bool) {\n        return T_REGISTRATION_END + DELTA_CONFIRM <= block.number;\n    }"
    ParameterList
       Source: "()"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\n        return T_REGISTRATION_END + DELTA_CONFIRM <= block.number;\n    }"
      Return
         Source: "return T_REGISTRATION_END + DELTA_CONFIRM <= block.number"
        BinaryOperation using operator <=
           Type: bool
           Source: "T_REGISTRATION_END + DELTA_CONFIRM <= block.number"
          BinaryOperation using operator +
             Type: uint256
             Source: "T_REGISTRATION_END + DELTA_CONFIRM"
            Identifier T_REGISTRATION_END
               Type: uint256
               Source: "T_REGISTRATION_END"
            Identifier DELTA_CONFIRM
               Type: uint256
               Source: "DELTA_CONFIRM"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
  FunctionDefinition "sharing_confirmed" - public - const
     Source: "function sharing_confirmed()\n    public view returns(bool) {\n        return T_SHARING_END + DELTA_CONFIRM <= block.number;\n    }"
    ParameterList
       Source: "()"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\n        return T_SHARING_END + DELTA_CONFIRM <= block.number;\n    }"
      Return
         Source: "return T_SHARING_END + DELTA_CONFIRM <= block.number"
        BinaryOperation using operator <=
           Type: bool
           Source: "T_SHARING_END + DELTA_CONFIRM <= block.number"
          BinaryOperation using operator +
             Type: uint256
             Source: "T_SHARING_END + DELTA_CONFIRM"
            Identifier T_SHARING_END
               Type: uint256
               Source: "T_SHARING_END"
            Identifier DELTA_CONFIRM
               Type: uint256
               Source: "DELTA_CONFIRM"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
  FunctionDefinition "dispute_confirmed" - public - const
     Source: "function dispute_confirmed()\n    public view returns(bool) {\n        return T_DISPUTE_END + DELTA_CONFIRM <= block.number;\n    }"
    ParameterList
       Source: "()"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\n        return T_DISPUTE_END + DELTA_CONFIRM <= block.number;\n    }"
      Return
         Source: "return T_DISPUTE_END + DELTA_CONFIRM <= block.number"
        BinaryOperation using operator <=
           Type: bool
           Source: "T_DISPUTE_END + DELTA_CONFIRM <= block.number"
          BinaryOperation using operator +
             Type: uint256
             Source: "T_DISPUTE_END + DELTA_CONFIRM"
            Identifier T_DISPUTE_END
               Type: uint256
               Source: "T_DISPUTE_END"
            Identifier DELTA_CONFIRM
               Type: uint256
               Source: "DELTA_CONFIRM"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
  FunctionDefinition "group_key_confirmed" - public - const
     Source: "function group_key_confirmed()\n    public view returns(bool) {\n        return (T_GROUP_KEY_UPLOAD != 0) && (T_GROUP_KEY_UPLOAD + DELTA_CONFIRM <= block.number);\n    }"
    ParameterList
       Source: "()"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\n        return (T_GROUP_KEY_UPLOAD != 0) && (T_GROUP_KEY_UPLOAD + DELTA_CONFIRM <= block.number);\n    }"
      Return
         Source: "return (T_GROUP_KEY_UPLOAD != 0) && (T_GROUP_KEY_UPLOAD + DELTA_CONFIRM <= block.number)"
        BinaryOperation using operator &&
           Type: bool
           Source: "(T_GROUP_KEY_UPLOAD != 0) && (T_GROUP_KEY_UPLOAD + DELTA_CONFIRM <= block.number)"
          TupleExpression
             Type: bool
             Source: "(T_GROUP_KEY_UPLOAD != 0)"
            BinaryOperation using operator !=
               Type: bool
               Source: "T_GROUP_KEY_UPLOAD != 0"
              Identifier T_GROUP_KEY_UPLOAD
                 Type: uint256
                 Source: "T_GROUP_KEY_UPLOAD"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          TupleExpression
             Type: bool
             Source: "(T_GROUP_KEY_UPLOAD + DELTA_CONFIRM <= block.number)"
            BinaryOperation using operator <=
               Type: bool
               Source: "T_GROUP_KEY_UPLOAD + DELTA_CONFIRM <= block.number"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "T_GROUP_KEY_UPLOAD + DELTA_CONFIRM"
                Identifier T_GROUP_KEY_UPLOAD
                   Type: uint256
                   Source: "T_GROUP_KEY_UPLOAD"
                Identifier DELTA_CONFIRM
                   Type: uint256
                   Source: "DELTA_CONFIRM"
              MemberAccess to member number
                 Type: uint256
                 Source: "block.number"
                Identifier block
                   Type: block
                   Source: "block"
  FunctionDefinition "register" - public
     Source: "function register(uint256[2] pk, uint256[4] bls_pk, uint256[2] sk_knowledge_proof) \n    public payable \n    {\n        require(in_registration_phase(), \"registration failed (contract is not in registration phase)\");\n        require(nodes[msg.sender].id == 0, \"registration failed (account already registered a public key)\");\n        require(\n            bn128_check_pairing(                                    // ensures that the given pk and bls_pk correspond to each other\n                [                                                   // i.e. that pk and bls_pk are of the form\n                    pk[0], pk[1],                                   // pk     =  g1 * sk\n                    g2xx, g2xy, g2yx, g2yy,                         // bls_pk = -g2 * sk\n                    g1x, g1y,                                       // for some secret key sk\n                    bls_pk[0], bls_pk[1], bls_pk[2], bls_pk[3]\n                ]), \n            \"registration failed (bls public key is invalid)\"\n        );\n        require(\n            verify_sk_knowledge(pk, sk_knowledge_proof), \n            \"registration failed (invalid proof of secret key knowlegde)\"\n        );\n\n        // TODO: check deposit\n\n        registered_addresses.push(msg.sender);\n        uint256 id = registered_addresses.length;        \n\n        nodes[msg.sender].id = id;\n        nodes[msg.sender].deposit = msg.value;\n        nodes[msg.sender].pk[0] = pk[0];\n        nodes[msg.sender].pk[1] = pk[1];\n        nodes[msg.sender].bls_pk[0] = bls_pk[0];\n        nodes[msg.sender].bls_pk[1] = bls_pk[1];\n        nodes[msg.sender].bls_pk[2] = bls_pk[2];\n        nodes[msg.sender].bls_pk[3] = bls_pk[3];\n\n        emit Registration(msg.sender, id, msg.value, pk, bls_pk);\n    }"
    ParameterList
       Source: "(uint256[2] pk, uint256[4] bls_pk, uint256[2] sk_knowledge_proof)"
      VariableDeclaration "pk"
         Type: uint256[2] memory
         Source: "uint256[2] pk"
        ArrayTypeName
           Source: "uint256[2]"
          ElementaryTypeName uint256
             Source: "uint256"
          Literal, token: [no token] value: 2
             Type unknown.
             Source: "2"
      VariableDeclaration "bls_pk"
         Type: uint256[4] memory
         Source: "uint256[4] bls_pk"
        ArrayTypeName
           Source: "uint256[4]"
          ElementaryTypeName uint256
             Source: "uint256"
          Literal, token: [no token] value: 4
             Type unknown.
             Source: "4"
      VariableDeclaration "sk_knowledge_proof"
         Type: uint256[2] memory
         Source: "uint256[2] sk_knowledge_proof"
        ArrayTypeName
           Source: "uint256[2]"
          ElementaryTypeName uint256
             Source: "uint256"
          Literal, token: [no token] value: 2
             Type unknown.
             Source: "2"
    ParameterList
       Source: ""
    Block
       Source: "{\n        require(in_registration_phase(), \"registration failed (contract is not in registration phase)\");\n        require(nodes[msg.sender].id == 0, \"registration failed (account already registered a public key)\");\n        require(\n            bn128_check_pairing(                                    // ensures that the given pk and bls_pk correspond to each other\n                [                                                   // i.e. that pk and bls_pk are of the form\n                    pk[0], pk[1],                                   // pk     =  g1 * sk\n                    g2xx, g2xy, g2yx, g2yy,                         // bls_pk = -g2 * sk\n                    g1x, g1y,                                       // for some secret key sk\n                    bls_pk[0], bls_pk[1], bls_pk[2], bls_pk[3]\n                ]), \n            \"registration failed (bls public key is invalid)\"\n        );\n        require(\n            verify_sk_knowledge(pk, sk_knowledge_proof), \n            \"registration failed (invalid proof of secret key knowlegde)\"\n        );\n\n        // TODO: check deposit\n\n        registered_addresses.push(msg.sender);\n        uint256 id = registered_addresses.length;        \n\n        nodes[msg.sender].id = id;\n        nodes[msg.sender].deposit = msg.value;\n        nodes[msg.sender].pk[0] = pk[0];\n        nodes[msg.sender].pk[1] = pk[1];\n        nodes[msg.sender].bls_pk[0] = bls_pk[0];\n        nodes[msg.sender].bls_pk[1] = bls_pk[1];\n        nodes[msg.sender].bls_pk[2] = bls_pk[2];\n        nodes[msg.sender].bls_pk[3] = bls_pk[3];\n\n        emit Registration(msg.sender, id, msg.value, pk, bls_pk);\n    }"
      ExpressionStatement
         Source: "require(in_registration_phase(), \"registration failed (contract is not in registration phase)\")"
        FunctionCall
           Type: tuple()
           Source: "require(in_registration_phase(), \"registration failed (contract is not in registration phase)\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "in_registration_phase()"
            Identifier in_registration_phase
               Type: function () view returns (bool)
               Source: "in_registration_phase"
          Literal, token: [no token] value: registration failed (contract is not in registration phase)
             Type: literal_string "registration failed (contract is not in registration phase)"
             Source: "\"registration failed (contract is not in registration phase)\""
      ExpressionStatement
         Source: "require(nodes[msg.sender].id == 0, \"registration failed (account already registered a public key)\")"
        FunctionCall
           Type: tuple()
           Source: "require(nodes[msg.sender].id == 0, \"registration failed (account already registered a public key)\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "nodes[msg.sender].id == 0"
            MemberAccess to member id
               Type: uint256
               Source: "nodes[msg.sender].id"
              IndexAccess
                 Type: struct DKG.Node storage ref
                 Source: "nodes[msg.sender]"
                Identifier nodes
                   Type: mapping(address => struct DKG.Node storage ref)
                   Source: "nodes"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          Literal, token: [no token] value: registration failed (account already registered a public key)
             Type: literal_string "registration failed (account already registered a public key)"
             Source: "\"registration failed (account already registered a public key)\""
      ExpressionStatement
         Source: "require(\n            bn128_check_pairing(                                    // ensures that the given pk and bls_pk correspond to each other\n                [                                                   // i.e. that pk and bls_pk are of the form\n                    pk[0], pk[1],                                   // pk     =  g1 * sk\n                    g2xx, g2xy, g2yx, g2yy,                         // bls_pk = -g2 * sk\n                    g1x, g1y,                                       // for some secret key sk\n                    bls_pk[0], bls_pk[1], bls_pk[2], bls_pk[3]\n                ]), \n            \"registration failed (bls public key is invalid)\"\n        )"
        FunctionCall
           Type: tuple()
           Source: "require(\n            bn128_check_pairing(                                    // ensures that the given pk and bls_pk correspond to each other\n                [                                                   // i.e. that pk and bls_pk are of the form\n                    pk[0], pk[1],                                   // pk     =  g1 * sk\n                    g2xx, g2xy, g2yx, g2yy,                         // bls_pk = -g2 * sk\n                    g1x, g1y,                                       // for some secret key sk\n                    bls_pk[0], bls_pk[1], bls_pk[2], bls_pk[3]\n                ]), \n            \"registration failed (bls public key is invalid)\"\n        )"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "bn128_check_pairing(                                    // ensures that the given pk and bls_pk correspond to each other\n                [                                                   // i.e. that pk and bls_pk are of the form\n                    pk[0], pk[1],                                   // pk     =  g1 * sk\n                    g2xx, g2xy, g2yx, g2yy,                         // bls_pk = -g2 * sk\n                    g1x, g1y,                                       // for some secret key sk\n                    bls_pk[0], bls_pk[1], bls_pk[2], bls_pk[3]\n                ])"
            Identifier bn128_check_pairing
               Type: function (uint256[12] memory) returns (bool)
               Source: "bn128_check_pairing"
            TupleExpression
               Type: uint256[12] memory
               Source: "[                                                   // i.e. that pk and bls_pk are of the form\n                    pk[0], pk[1],                                   // pk     =  g1 * sk\n                    g2xx, g2xy, g2yx, g2yy,                         // bls_pk = -g2 * sk\n                    g1x, g1y,                                       // for some secret key sk\n                    bls_pk[0], bls_pk[1], bls_pk[2], bls_pk[3]\n                ]"
              IndexAccess
                 Type: uint256
                 Source: "pk[0]"
                Identifier pk
                   Type: uint256[2] memory
                   Source: "pk"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              IndexAccess
                 Type: uint256
                 Source: "pk[1]"
                Identifier pk
                   Type: uint256[2] memory
                   Source: "pk"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
              Identifier g2xx
                 Type: uint256
                 Source: "g2xx"
              Identifier g2xy
                 Type: uint256
                 Source: "g2xy"
              Identifier g2yx
                 Type: uint256
                 Source: "g2yx"
              Identifier g2yy
                 Type: uint256
                 Source: "g2yy"
              Identifier g1x
                 Type: uint256
                 Source: "g1x"
              Identifier g1y
                 Type: uint256
                 Source: "g1y"
              IndexAccess
                 Type: uint256
                 Source: "bls_pk[0]"
                Identifier bls_pk
                   Type: uint256[4] memory
                   Source: "bls_pk"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              IndexAccess
                 Type: uint256
                 Source: "bls_pk[1]"
                Identifier bls_pk
                   Type: uint256[4] memory
                   Source: "bls_pk"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
              IndexAccess
                 Type: uint256
                 Source: "bls_pk[2]"
                Identifier bls_pk
                   Type: uint256[4] memory
                   Source: "bls_pk"
                Literal, token: [no token] value: 2
                   Type: int_const 2
                   Source: "2"
              IndexAccess
                 Type: uint256
                 Source: "bls_pk[3]"
                Identifier bls_pk
                   Type: uint256[4] memory
                   Source: "bls_pk"
                Literal, token: [no token] value: 3
                   Type: int_const 3
                   Source: "3"
          Literal, token: [no token] value: registration failed (bls public key is invalid)
             Type: literal_string "registration failed (bls public key is invalid)"
             Source: "\"registration failed (bls public key is invalid)\""
      ExpressionStatement
         Source: "require(\n            verify_sk_knowledge(pk, sk_knowledge_proof), \n            \"registration failed (invalid proof of secret key knowlegde)\"\n        )"
        FunctionCall
           Type: tuple()
           Source: "require(\n            verify_sk_knowledge(pk, sk_knowledge_proof), \n            \"registration failed (invalid proof of secret key knowlegde)\"\n        )"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "verify_sk_knowledge(pk, sk_knowledge_proof)"
            Identifier verify_sk_knowledge
               Type: function (uint256[2] memory,uint256[2] memory) returns (bool)
               Source: "verify_sk_knowledge"
            Identifier pk
               Type: uint256[2] memory
               Source: "pk"
            Identifier sk_knowledge_proof
               Type: uint256[2] memory
               Source: "sk_knowledge_proof"
          Literal, token: [no token] value: registration failed (invalid proof of secret key knowlegde)
             Type: literal_string "registration failed (invalid proof of secret key knowlegde)"
             Source: "\"registration failed (invalid proof of secret key knowlegde)\""
      ExpressionStatement
         Source: "registered_addresses.push(msg.sender)"
        FunctionCall
           Type: uint256
           Source: "registered_addresses.push(msg.sender)"
          MemberAccess to member push
             Type: function (address) returns (uint256)
             Source: "registered_addresses.push"
            Identifier registered_addresses
               Type: address[] storage ref
               Source: "registered_addresses"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      VariableDeclarationStatement
         Source: "uint256 id = registered_addresses.length"
        VariableDeclaration "id"
           Type: uint256
           Source: "uint256 id"
          ElementaryTypeName uint256
             Source: "uint256"
        MemberAccess to member length
           Type: uint256
           Source: "registered_addresses.length"
          Identifier registered_addresses
             Type: address[] storage ref
             Source: "registered_addresses"
      ExpressionStatement
         Source: "nodes[msg.sender].id = id"
        Assignment using operator =
           Type: uint256
           Source: "nodes[msg.sender].id = id"
          MemberAccess to member id
             Type: uint256
             Source: "nodes[msg.sender].id"
            IndexAccess
               Type: struct DKG.Node storage ref
               Source: "nodes[msg.sender]"
              Identifier nodes
                 Type: mapping(address => struct DKG.Node storage ref)
                 Source: "nodes"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
          Identifier id
             Type: uint256
             Source: "id"
      ExpressionStatement
         Source: "nodes[msg.sender].deposit = msg.value"
        Assignment using operator =
           Type: uint256
           Source: "nodes[msg.sender].deposit = msg.value"
          MemberAccess to member deposit
             Type: uint256
             Source: "nodes[msg.sender].deposit"
            IndexAccess
               Type: struct DKG.Node storage ref
               Source: "nodes[msg.sender]"
              Identifier nodes
                 Type: mapping(address => struct DKG.Node storage ref)
                 Source: "nodes"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Source: "nodes[msg.sender].pk[0] = pk[0]"
        Assignment using operator =
           Type: uint256
           Source: "nodes[msg.sender].pk[0] = pk[0]"
          IndexAccess
             Type: uint256
             Source: "nodes[msg.sender].pk[0]"
            MemberAccess to member pk
               Type: uint256[2] storage ref
               Source: "nodes[msg.sender].pk"
              IndexAccess
                 Type: struct DKG.Node storage ref
                 Source: "nodes[msg.sender]"
                Identifier nodes
                   Type: mapping(address => struct DKG.Node storage ref)
                   Source: "nodes"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          IndexAccess
             Type: uint256
             Source: "pk[0]"
            Identifier pk
               Type: uint256[2] memory
               Source: "pk"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Source: "nodes[msg.sender].pk[1] = pk[1]"
        Assignment using operator =
           Type: uint256
           Source: "nodes[msg.sender].pk[1] = pk[1]"
          IndexAccess
             Type: uint256
             Source: "nodes[msg.sender].pk[1]"
            MemberAccess to member pk
               Type: uint256[2] storage ref
               Source: "nodes[msg.sender].pk"
              IndexAccess
                 Type: struct DKG.Node storage ref
                 Source: "nodes[msg.sender]"
                Identifier nodes
                   Type: mapping(address => struct DKG.Node storage ref)
                   Source: "nodes"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
          IndexAccess
             Type: uint256
             Source: "pk[1]"
            Identifier pk
               Type: uint256[2] memory
               Source: "pk"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
      ExpressionStatement
         Source: "nodes[msg.sender].bls_pk[0] = bls_pk[0]"
        Assignment using operator =
           Type: uint256
           Source: "nodes[msg.sender].bls_pk[0] = bls_pk[0]"
          IndexAccess
             Type: uint256
             Source: "nodes[msg.sender].bls_pk[0]"
            MemberAccess to member bls_pk
               Type: uint256[4] storage ref
               Source: "nodes[msg.sender].bls_pk"
              IndexAccess
                 Type: struct DKG.Node storage ref
                 Source: "nodes[msg.sender]"
                Identifier nodes
                   Type: mapping(address => struct DKG.Node storage ref)
                   Source: "nodes"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          IndexAccess
             Type: uint256
             Source: "bls_pk[0]"
            Identifier bls_pk
               Type: uint256[4] memory
               Source: "bls_pk"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Source: "nodes[msg.sender].bls_pk[1] = bls_pk[1]"
        Assignment using operator =
           Type: uint256
           Source: "nodes[msg.sender].bls_pk[1] = bls_pk[1]"
          IndexAccess
             Type: uint256
             Source: "nodes[msg.sender].bls_pk[1]"
            MemberAccess to member bls_pk
               Type: uint256[4] storage ref
               Source: "nodes[msg.sender].bls_pk"
              IndexAccess
                 Type: struct DKG.Node storage ref
                 Source: "nodes[msg.sender]"
                Identifier nodes
                   Type: mapping(address => struct DKG.Node storage ref)
                   Source: "nodes"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
          IndexAccess
             Type: uint256
             Source: "bls_pk[1]"
            Identifier bls_pk
               Type: uint256[4] memory
               Source: "bls_pk"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
      ExpressionStatement
         Source: "nodes[msg.sender].bls_pk[2] = bls_pk[2]"
        Assignment using operator =
           Type: uint256
           Source: "nodes[msg.sender].bls_pk[2] = bls_pk[2]"
          IndexAccess
             Type: uint256
             Source: "nodes[msg.sender].bls_pk[2]"
            MemberAccess to member bls_pk
               Type: uint256[4] storage ref
               Source: "nodes[msg.sender].bls_pk"
              IndexAccess
                 Type: struct DKG.Node storage ref
                 Source: "nodes[msg.sender]"
                Identifier nodes
                   Type: mapping(address => struct DKG.Node storage ref)
                   Source: "nodes"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
            Literal, token: [no token] value: 2
               Type: int_const 2
               Source: "2"
          IndexAccess
             Type: uint256
             Source: "bls_pk[2]"
            Identifier bls_pk
               Type: uint256[4] memory
               Source: "bls_pk"
            Literal, token: [no token] value: 2
               Type: int_const 2
               Source: "2"
      ExpressionStatement
         Source: "nodes[msg.sender].bls_pk[3] = bls_pk[3]"
        Assignment using operator =
           Type: uint256
           Source: "nodes[msg.sender].bls_pk[3] = bls_pk[3]"
          IndexAccess
             Type: uint256
             Source: "nodes[msg.sender].bls_pk[3]"
            MemberAccess to member bls_pk
               Type: uint256[4] storage ref
               Source: "nodes[msg.sender].bls_pk"
              IndexAccess
                 Type: struct DKG.Node storage ref
                 Source: "nodes[msg.sender]"
                Identifier nodes
                   Type: mapping(address => struct DKG.Node storage ref)
                   Source: "nodes"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
            Literal, token: [no token] value: 3
               Type: int_const 3
               Source: "3"
          IndexAccess
             Type: uint256
             Source: "bls_pk[3]"
            Identifier bls_pk
               Type: uint256[4] memory
               Source: "bls_pk"
            Literal, token: [no token] value: 3
               Type: int_const 3
               Source: "3"
      EmitStatement
         Source: "emit Registration(msg.sender, id, msg.value, pk, bls_pk)"
        FunctionCall
           Type: tuple()
           Source: "Registration(msg.sender, id, msg.value, pk, bls_pk)"
          Identifier Registration
             Type: function (address,uint256,uint256,uint256[2] memory,uint256[4] memory)
             Source: "Registration"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier id
             Type: uint256
             Source: "id"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier pk
             Type: uint256[2] memory
             Source: "pk"
          Identifier bls_pk
             Type: uint256[4] memory
             Source: "bls_pk"
  FunctionDefinition "share_key" - public
     Source: "function share_key(\n        uint256[] encrypted_shares,     // Enc_kAB(s_i), each 256 bit\n        uint256[] public_coefficients)  // Cj, each 512 bit\n    public\n    {\n        uint256 n = registered_addresses.length;\n        uint256 t = (n / 2) + 1;\n        uint256 issuer_id = nodes[msg.sender].id;\n\n        require(in_sharing_phase(), \"key sharing failed (contract is not in sharing phase)\");\n        require(issuer_id > 0, \"key sharing failed (ethereum account has not registered)\");\n        require(encrypted_shares.length == n - 1, \"key sharing failed (invalid number of encrypted shares provided)\");\n        require(public_coefficients.length == t * 2 - 2, \"key sharing failed (invalid number of commitments provided)\");\n\n        // for optimization we only store the hash of the submitted data\n        // and emit an event with the actual data\n        nodes[msg.sender].key_distribution_hash = keccak256(abi.encodePacked(encrypted_shares, public_coefficients));\n        emit KeySharing(issuer_id, encrypted_shares, public_coefficients);\n    }"
    ParameterList
       Source: "(\n        uint256[] encrypted_shares,     // Enc_kAB(s_i), each 256 bit\n        uint256[] public_coefficients)"
      VariableDeclaration "encrypted_shares"
         Type: uint256[] memory
         Source: "uint256[] encrypted_shares"
        ArrayTypeName
           Source: "uint256[]"
          ElementaryTypeName uint256
             Source: "uint256"
      VariableDeclaration "public_coefficients"
         Type: uint256[] memory
         Source: "uint256[] public_coefficients"
        ArrayTypeName
           Source: "uint256[]"
          ElementaryTypeName uint256
             Source: "uint256"
    ParameterList
       Source: ""
    Block
       Source: "{\n        uint256 n = registered_addresses.length;\n        uint256 t = (n / 2) + 1;\n        uint256 issuer_id = nodes[msg.sender].id;\n\n        require(in_sharing_phase(), \"key sharing failed (contract is not in sharing phase)\");\n        require(issuer_id > 0, \"key sharing failed (ethereum account has not registered)\");\n        require(encrypted_shares.length == n - 1, \"key sharing failed (invalid number of encrypted shares provided)\");\n        require(public_coefficients.length == t * 2 - 2, \"key sharing failed (invalid number of commitments provided)\");\n\n        // for optimization we only store the hash of the submitted data\n        // and emit an event with the actual data\n        nodes[msg.sender].key_distribution_hash = keccak256(abi.encodePacked(encrypted_shares, public_coefficients));\n        emit KeySharing(issuer_id, encrypted_shares, public_coefficients);\n    }"
      VariableDeclarationStatement
         Source: "uint256 n = registered_addresses.length"
        VariableDeclaration "n"
           Type: uint256
           Source: "uint256 n"
          ElementaryTypeName uint256
             Source: "uint256"
        MemberAccess to member length
           Type: uint256
           Source: "registered_addresses.length"
          Identifier registered_addresses
             Type: address[] storage ref
             Source: "registered_addresses"
      VariableDeclarationStatement
         Source: "uint256 t = (n / 2) + 1"
        VariableDeclaration "t"
           Type: uint256
           Source: "uint256 t"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator +
           Type: uint256
           Source: "(n / 2) + 1"
          TupleExpression
             Type: uint256
             Source: "(n / 2)"
            BinaryOperation using operator /
               Type: uint256
               Source: "n / 2"
              Identifier n
                 Type: uint256
                 Source: "n"
              Literal, token: [no token] value: 2
                 Type: int_const 2
                 Source: "2"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
      VariableDeclarationStatement
         Source: "uint256 issuer_id = nodes[msg.sender].id"
        VariableDeclaration "issuer_id"
           Type: uint256
           Source: "uint256 issuer_id"
          ElementaryTypeName uint256
             Source: "uint256"
        MemberAccess to member id
           Type: uint256
           Source: "nodes[msg.sender].id"
          IndexAccess
             Type: struct DKG.Node storage ref
             Source: "nodes[msg.sender]"
            Identifier nodes
               Type: mapping(address => struct DKG.Node storage ref)
               Source: "nodes"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
      ExpressionStatement
         Source: "require(in_sharing_phase(), \"key sharing failed (contract is not in sharing phase)\")"
        FunctionCall
           Type: tuple()
           Source: "require(in_sharing_phase(), \"key sharing failed (contract is not in sharing phase)\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "in_sharing_phase()"
            Identifier in_sharing_phase
               Type: function () view returns (bool)
               Source: "in_sharing_phase"
          Literal, token: [no token] value: key sharing failed (contract is not in sharing phase)
             Type: literal_string "key sharing failed (contract is not in sharing phase)"
             Source: "\"key sharing failed (contract is not in sharing phase)\""
      ExpressionStatement
         Source: "require(issuer_id > 0, \"key sharing failed (ethereum account has not registered)\")"
        FunctionCall
           Type: tuple()
           Source: "require(issuer_id > 0, \"key sharing failed (ethereum account has not registered)\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "issuer_id > 0"
            Identifier issuer_id
               Type: uint256
               Source: "issuer_id"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          Literal, token: [no token] value: key sharing failed (ethereum account has not registered)
             Type: literal_string "key sharing failed (ethereum account has not registered)"
             Source: "\"key sharing failed (ethereum account has not registered)\""
      ExpressionStatement
         Source: "require(encrypted_shares.length == n - 1, \"key sharing failed (invalid number of encrypted shares provided)\")"
        FunctionCall
           Type: tuple()
           Source: "require(encrypted_shares.length == n - 1, \"key sharing failed (invalid number of encrypted shares provided)\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "encrypted_shares.length == n - 1"
            MemberAccess to member length
               Type: uint256
               Source: "encrypted_shares.length"
              Identifier encrypted_shares
                 Type: uint256[] memory
                 Source: "encrypted_shares"
            BinaryOperation using operator -
               Type: uint256
               Source: "n - 1"
              Identifier n
                 Type: uint256
                 Source: "n"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
          Literal, token: [no token] value: key sharing failed (invalid number of encrypted shares provided)
             Type: literal_string "key sharing failed (invalid number of encrypted shares provided)"
             Source: "\"key sharing failed (invalid number of encrypted shares provided)\""
      ExpressionStatement
         Source: "require(public_coefficients.length == t * 2 - 2, \"key sharing failed (invalid number of commitments provided)\")"
        FunctionCall
           Type: tuple()
           Source: "require(public_coefficients.length == t * 2 - 2, \"key sharing failed (invalid number of commitments provided)\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "public_coefficients.length == t * 2 - 2"
            MemberAccess to member length
               Type: uint256
               Source: "public_coefficients.length"
              Identifier public_coefficients
                 Type: uint256[] memory
                 Source: "public_coefficients"
            BinaryOperation using operator -
               Type: uint256
               Source: "t * 2 - 2"
              BinaryOperation using operator *
                 Type: uint256
                 Source: "t * 2"
                Identifier t
                   Type: uint256
                   Source: "t"
                Literal, token: [no token] value: 2
                   Type: int_const 2
                   Source: "2"
              Literal, token: [no token] value: 2
                 Type: int_const 2
                 Source: "2"
          Literal, token: [no token] value: key sharing failed (invalid number of commitments provided)
             Type: literal_string "key sharing failed (invalid number of commitments provided)"
             Source: "\"key sharing failed (invalid number of commitments provided)\""
      ExpressionStatement
         Source: "nodes[msg.sender].key_distribution_hash = keccak256(abi.encodePacked(encrypted_shares, public_coefficients))"
        Assignment using operator =
           Type: bytes32
           Source: "nodes[msg.sender].key_distribution_hash = keccak256(abi.encodePacked(encrypted_shares, public_coefficients))"
          MemberAccess to member key_distribution_hash
             Type: bytes32
             Source: "nodes[msg.sender].key_distribution_hash"
            IndexAccess
               Type: struct DKG.Node storage ref
               Source: "nodes[msg.sender]"
              Identifier nodes
                 Type: mapping(address => struct DKG.Node storage ref)
                 Source: "nodes"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
          FunctionCall
             Type: bytes32
             Source: "keccak256(abi.encodePacked(encrypted_shares, public_coefficients))"
            Identifier keccak256
               Type: function () pure returns (bytes32)
               Source: "keccak256"
            FunctionCall
               Type: bytes memory
               Source: "abi.encodePacked(encrypted_shares, public_coefficients)"
              MemberAccess to member encodePacked
                 Type: function () pure returns (bytes memory)
                 Source: "abi.encodePacked"
                Identifier abi
                   Type: abi
                   Source: "abi"
              Identifier encrypted_shares
                 Type: uint256[] memory
                 Source: "encrypted_shares"
              Identifier public_coefficients
                 Type: uint256[] memory
                 Source: "public_coefficients"
      EmitStatement
         Source: "emit KeySharing(issuer_id, encrypted_shares, public_coefficients)"
        FunctionCall
           Type: tuple()
           Source: "KeySharing(issuer_id, encrypted_shares, public_coefficients)"
          Identifier KeySharing
             Type: function (uint256,uint256[] memory,uint256[] memory)
             Source: "KeySharing"
          Identifier issuer_id
             Type: uint256
             Source: "issuer_id"
          Identifier encrypted_shares
             Type: uint256[] memory
             Source: "encrypted_shares"
          Identifier public_coefficients
             Type: uint256[] memory
             Source: "public_coefficients"
  FunctionDefinition "dispute_public_coefficient" - public
     Source: "function dispute_public_coefficient(\n        address issuer_addr,             // the node which is accussed to have distributed (at least one) invalid coefficient\n        uint256[] encrypted_shares,      // the data from previous KeySharing event\n        uint256[] public_coefficients,   // the data from previous KeySharing event\n        uint256 invalid_coefficient_idx  // specifies any coefficient which is invalid (used for efficiency)\n    ) \n    public\n    {\n        Node storage issuer = nodes[issuer_addr];\n        Node storage verifier = nodes[msg.sender];\n\n        require(in_dispute_phase(), \"dispute failed (contract is not in sharing phase)\");\n        require(issuer.id > 0, \"dispute failed/aborted (issuer not registered or slashed)\");\n        require(verifier.id > 0, \"dispute failed/aborted (verifier not registered or slashed)\");\n        require(issuer.id != verifier.id, \"dispute failed (self dispute is not allowed)\");\n        require(\n            issuer.key_distribution_hash == keccak256(abi.encodePacked(encrypted_shares, public_coefficients)),\n            \"dispute failed (encrypted shares and/or public coefficients not matching)\"\n        );\n\n        uint256 i = invalid_coefficient_idx * 2;\n        require(\n            !bn128_is_on_curve([public_coefficients[i], public_coefficients[i + 1]]),\n            \"dispute failed (coefficient is actually valid)\"\n        );\n\n        __slash__(issuer_addr);\n    }"
    ParameterList
       Source: "(\n        address issuer_addr,             // the node which is accussed to have distributed (at least one) invalid coefficient\n        uint256[] encrypted_shares,      // the data from previous KeySharing event\n        uint256[] public_coefficients,   // the data from previous KeySharing event\n        uint256 invalid_coefficient_idx  // specifies any coefficient which is invalid (used for efficiency)\n    )"
      VariableDeclaration "issuer_addr"
         Type: address
         Source: "address issuer_addr"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "encrypted_shares"
         Type: uint256[] memory
         Source: "uint256[] encrypted_shares"
        ArrayTypeName
           Source: "uint256[]"
          ElementaryTypeName uint256
             Source: "uint256"
      VariableDeclaration "public_coefficients"
         Type: uint256[] memory
         Source: "uint256[] public_coefficients"
        ArrayTypeName
           Source: "uint256[]"
          ElementaryTypeName uint256
             Source: "uint256"
      VariableDeclaration "invalid_coefficient_idx"
         Type: uint256
         Source: "uint256 invalid_coefficient_idx"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: ""
    Block
       Source: "{\n        Node storage issuer = nodes[issuer_addr];\n        Node storage verifier = nodes[msg.sender];\n\n        require(in_dispute_phase(), \"dispute failed (contract is not in sharing phase)\");\n        require(issuer.id > 0, \"dispute failed/aborted (issuer not registered or slashed)\");\n        require(verifier.id > 0, \"dispute failed/aborted (verifier not registered or slashed)\");\n        require(issuer.id != verifier.id, \"dispute failed (self dispute is not allowed)\");\n        require(\n            issuer.key_distribution_hash == keccak256(abi.encodePacked(encrypted_shares, public_coefficients)),\n            \"dispute failed (encrypted shares and/or public coefficients not matching)\"\n        );\n\n        uint256 i = invalid_coefficient_idx * 2;\n        require(\n            !bn128_is_on_curve([public_coefficients[i], public_coefficients[i + 1]]),\n            \"dispute failed (coefficient is actually valid)\"\n        );\n\n        __slash__(issuer_addr);\n    }"
      VariableDeclarationStatement
         Source: "Node storage issuer = nodes[issuer_addr]"
        VariableDeclaration "issuer"
           Type: struct DKG.Node storage pointer
           Source: "Node storage issuer"
          UserDefinedTypeName "Node"
             Source: "Node"
        IndexAccess
           Type: struct DKG.Node storage ref
           Source: "nodes[issuer_addr]"
          Identifier nodes
             Type: mapping(address => struct DKG.Node storage ref)
             Source: "nodes"
          Identifier issuer_addr
             Type: address
             Source: "issuer_addr"
      VariableDeclarationStatement
         Source: "Node storage verifier = nodes[msg.sender]"
        VariableDeclaration "verifier"
           Type: struct DKG.Node storage pointer
           Source: "Node storage verifier"
          UserDefinedTypeName "Node"
             Source: "Node"
        IndexAccess
           Type: struct DKG.Node storage ref
           Source: "nodes[msg.sender]"
          Identifier nodes
             Type: mapping(address => struct DKG.Node storage ref)
             Source: "nodes"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Source: "require(in_dispute_phase(), \"dispute failed (contract is not in sharing phase)\")"
        FunctionCall
           Type: tuple()
           Source: "require(in_dispute_phase(), \"dispute failed (contract is not in sharing phase)\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "in_dispute_phase()"
            Identifier in_dispute_phase
               Type: function () view returns (bool)
               Source: "in_dispute_phase"
          Literal, token: [no token] value: dispute failed (contract is not in sharing phase)
             Type: literal_string "dispute failed (contract is not in sharing phase)"
             Source: "\"dispute failed (contract is not in sharing phase)\""
      ExpressionStatement
         Source: "require(issuer.id > 0, \"dispute failed/aborted (issuer not registered or slashed)\")"
        FunctionCall
           Type: tuple()
           Source: "require(issuer.id > 0, \"dispute failed/aborted (issuer not registered or slashed)\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "issuer.id > 0"
            MemberAccess to member id
               Type: uint256
               Source: "issuer.id"
              Identifier issuer
                 Type: struct DKG.Node storage pointer
                 Source: "issuer"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          Literal, token: [no token] value: dispute failed/aborted (issuer not registered or slashed)
             Type: literal_string "dispute failed/aborted (issuer not registered or slashed)"
             Source: "\"dispute failed/aborted (issuer not registered or slashed)\""
      ExpressionStatement
         Source: "require(verifier.id > 0, \"dispute failed/aborted (verifier not registered or slashed)\")"
        FunctionCall
           Type: tuple()
           Source: "require(verifier.id > 0, \"dispute failed/aborted (verifier not registered or slashed)\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "verifier.id > 0"
            MemberAccess to member id
               Type: uint256
               Source: "verifier.id"
              Identifier verifier
                 Type: struct DKG.Node storage pointer
                 Source: "verifier"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          Literal, token: [no token] value: dispute failed/aborted (verifier not registered or slashed)
             Type: literal_string "dispute failed/aborted (verifier not registered or slashed)"
             Source: "\"dispute failed/aborted (verifier not registered or slashed)\""
      ExpressionStatement
         Source: "require(issuer.id != verifier.id, \"dispute failed (self dispute is not allowed)\")"
        FunctionCall
           Type: tuple()
           Source: "require(issuer.id != verifier.id, \"dispute failed (self dispute is not allowed)\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "issuer.id != verifier.id"
            MemberAccess to member id
               Type: uint256
               Source: "issuer.id"
              Identifier issuer
                 Type: struct DKG.Node storage pointer
                 Source: "issuer"
            MemberAccess to member id
               Type: uint256
               Source: "verifier.id"
              Identifier verifier
                 Type: struct DKG.Node storage pointer
                 Source: "verifier"
          Literal, token: [no token] value: dispute failed (self dispute is not allowed)
             Type: literal_string "dispute failed (self dispute is not allowed)"
             Source: "\"dispute failed (self dispute is not allowed)\""
      ExpressionStatement
         Source: "require(\n            issuer.key_distribution_hash == keccak256(abi.encodePacked(encrypted_shares, public_coefficients)),\n            \"dispute failed (encrypted shares and/or public coefficients not matching)\"\n        )"
        FunctionCall
           Type: tuple()
           Source: "require(\n            issuer.key_distribution_hash == keccak256(abi.encodePacked(encrypted_shares, public_coefficients)),\n            \"dispute failed (encrypted shares and/or public coefficients not matching)\"\n        )"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "issuer.key_distribution_hash == keccak256(abi.encodePacked(encrypted_shares, public_coefficients))"
            MemberAccess to member key_distribution_hash
               Type: bytes32
               Source: "issuer.key_distribution_hash"
              Identifier issuer
                 Type: struct DKG.Node storage pointer
                 Source: "issuer"
            FunctionCall
               Type: bytes32
               Source: "keccak256(abi.encodePacked(encrypted_shares, public_coefficients))"
              Identifier keccak256
                 Type: function () pure returns (bytes32)
                 Source: "keccak256"
              FunctionCall
                 Type: bytes memory
                 Source: "abi.encodePacked(encrypted_shares, public_coefficients)"
                MemberAccess to member encodePacked
                   Type: function () pure returns (bytes memory)
                   Source: "abi.encodePacked"
                  Identifier abi
                     Type: abi
                     Source: "abi"
                Identifier encrypted_shares
                   Type: uint256[] memory
                   Source: "encrypted_shares"
                Identifier public_coefficients
                   Type: uint256[] memory
                   Source: "public_coefficients"
          Literal, token: [no token] value: dispute failed (encrypted shares and/or public coefficients not matching)
             Type: literal_string "dispute failed (encrypted shares and/or public coefficients not matching)"
             Source: "\"dispute failed (encrypted shares and/or public coefficients not matching)\""
      VariableDeclarationStatement
         Source: "uint256 i = invalid_coefficient_idx * 2"
        VariableDeclaration "i"
           Type: uint256
           Source: "uint256 i"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator *
           Type: uint256
           Source: "invalid_coefficient_idx * 2"
          Identifier invalid_coefficient_idx
             Type: uint256
             Source: "invalid_coefficient_idx"
          Literal, token: [no token] value: 2
             Type: int_const 2
             Source: "2"
      ExpressionStatement
         Source: "require(\n            !bn128_is_on_curve([public_coefficients[i], public_coefficients[i + 1]]),\n            \"dispute failed (coefficient is actually valid)\"\n        )"
        FunctionCall
           Type: tuple()
           Source: "require(\n            !bn128_is_on_curve([public_coefficients[i], public_coefficients[i + 1]]),\n            \"dispute failed (coefficient is actually valid)\"\n        )"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!bn128_is_on_curve([public_coefficients[i], public_coefficients[i + 1]])"
            FunctionCall
               Type: bool
               Source: "bn128_is_on_curve([public_coefficients[i], public_coefficients[i + 1]])"
              Identifier bn128_is_on_curve
                 Type: function (uint256[2] memory) returns (bool)
                 Source: "bn128_is_on_curve"
              TupleExpression
                 Type: uint256[2] memory
                 Source: "[public_coefficients[i], public_coefficients[i + 1]]"
                IndexAccess
                   Type: uint256
                   Source: "public_coefficients[i]"
                  Identifier public_coefficients
                     Type: uint256[] memory
                     Source: "public_coefficients"
                  Identifier i
                     Type: uint256
                     Source: "i"
                IndexAccess
                   Type: uint256
                   Source: "public_coefficients[i + 1]"
                  Identifier public_coefficients
                     Type: uint256[] memory
                     Source: "public_coefficients"
                  BinaryOperation using operator +
                     Type: uint256
                     Source: "i + 1"
                    Identifier i
                       Type: uint256
                       Source: "i"
                    Literal, token: [no token] value: 1
                       Type: int_const 1
                       Source: "1"
          Literal, token: [no token] value: dispute failed (coefficient is actually valid)
             Type: literal_string "dispute failed (coefficient is actually valid)"
             Source: "\"dispute failed (coefficient is actually valid)\""
      ExpressionStatement
         Source: "__slash__(issuer_addr)"
        FunctionCall
           Type: tuple()
           Source: "__slash__(issuer_addr)"
          Identifier __slash__
             Type: function (address)
             Source: "__slash__"
          Identifier issuer_addr
             Type: address
             Source: "issuer_addr"
  FunctionDefinition "dispute_share" - public
     Source: "function dispute_share(\n        address issuer_addr,             // the node which is accussed to have distributed an invalid share\n        uint256[] encrypted_shares,      // the data from previous KeyDistribution event\n        uint256[] public_coefficients,   // the data from previous KeyDistribution event\n        uint256[2] decryption_key,       // shared key between issuer and calling node\n        uint256[2] decryption_key_proof) // NIZK proof, showing that decryption key is valid\n    public\n    {\n        Node storage issuer = nodes[issuer_addr];\n        Node storage verifier = nodes[msg.sender];\n\n        require(in_dispute_phase(), \"dispute failed (contract is not in sharing phase)\");\n        require(issuer.id > 0, \"dispute failed/aborted (issuer not registered or slashed)\");\n        require(verifier.id > 0, \"dispute failed/aborted (verifier not registered or slashed)\");\n        require(issuer.id != verifier.id, \"dispute failed (self dispute is not allowed)\");\n        require(\n            issuer.key_distribution_hash == keccak256(abi.encodePacked(encrypted_shares, public_coefficients)),\n            \"dispute failed (encrypted shares and/or public coefficients not matching)\"\n        );\n        require(\n            verify_decryption_key(decryption_key, decryption_key_proof, verifier.pk, issuer.pk),\n            \"dispute failed (invalid decryption key or decryption key proof)\"\n        );\n\n        // compute share index i:\n        // the index i is one-based (which is required!) (indepent of the correction below)\n        // as the issuer does not provide a share for itself the index has to be corrected\n        uint256 i = verifier.id;\n        if (i > issuer.id) {\n            i--;\n        }\n\n        // decryption of the share, (correct for one-based index i to make it zero-based)\n        uint256 share = encrypted_shares[i - 1] ^ uint256(keccak256(abi.encodePacked(decryption_key[0], verifier.id)));\n        // require(false, \"test assert here\");\n        \n        // verify that share is actually invalid\n        // evaluate the poly polynom F(x) for x = i\n        uint256 x = i;\n        uint256[2] memory Fx = [ issuer.pk[0], issuer.pk[1] ];\n        uint256[2] memory tmp = bn128_multiply([public_coefficients[0], public_coefficients[1], x]);\n        Fx = bn128_add([Fx[0], Fx[1], tmp[0], tmp[1]]);\n\n        for (uint256 j = 2; j < public_coefficients.length; j += 2) { \n            x = mulmod(x, i, GROUP_ORDER);\n            tmp = bn128_multiply([public_coefficients[j], public_coefficients[j + 1], x]);\n            Fx = bn128_add([Fx[0], Fx[1], tmp[0], tmp[1]]);\n        }\n        // and compare the result (stored in Fx) with g1*si\n        uint256[2] memory Fi = bn128_multiply([g1x, g1y, share]);   \n\n        // require that share is actually invalid\n        require(Fx[0] != Fi[0] || Fx[1] != Fi[1], \"dispute failed (the provided share was valid)\");\n\n        __slash__(issuer_addr);\n    }"
    ParameterList
       Source: "(\n        address issuer_addr,             // the node which is accussed to have distributed an invalid share\n        uint256[] encrypted_shares,      // the data from previous KeyDistribution event\n        uint256[] public_coefficients,   // the data from previous KeyDistribution event\n        uint256[2] decryption_key,       // shared key between issuer and calling node\n        uint256[2] decryption_key_proof)"
      VariableDeclaration "issuer_addr"
         Type: address
         Source: "address issuer_addr"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "encrypted_shares"
         Type: uint256[] memory
         Source: "uint256[] encrypted_shares"
        ArrayTypeName
           Source: "uint256[]"
          ElementaryTypeName uint256
             Source: "uint256"
      VariableDeclaration "public_coefficients"
         Type: uint256[] memory
         Source: "uint256[] public_coefficients"
        ArrayTypeName
           Source: "uint256[]"
          ElementaryTypeName uint256
             Source: "uint256"
      VariableDeclaration "decryption_key"
         Type: uint256[2] memory
         Source: "uint256[2] decryption_key"
        ArrayTypeName
           Source: "uint256[2]"
          ElementaryTypeName uint256
             Source: "uint256"
          Literal, token: [no token] value: 2
             Type unknown.
             Source: "2"
      VariableDeclaration "decryption_key_proof"
         Type: uint256[2] memory
         Source: "uint256[2] decryption_key_proof"
        ArrayTypeName
           Source: "uint256[2]"
          ElementaryTypeName uint256
             Source: "uint256"
          Literal, token: [no token] value: 2
             Type unknown.
             Source: "2"
    ParameterList
       Source: ""
    Block
       Source: "{\n        Node storage issuer = nodes[issuer_addr];\n        Node storage verifier = nodes[msg.sender];\n\n        require(in_dispute_phase(), \"dispute failed (contract is not in sharing phase)\");\n        require(issuer.id > 0, \"dispute failed/aborted (issuer not registered or slashed)\");\n        require(verifier.id > 0, \"dispute failed/aborted (verifier not registered or slashed)\");\n        require(issuer.id != verifier.id, \"dispute failed (self dispute is not allowed)\");\n        require(\n            issuer.key_distribution_hash == keccak256(abi.encodePacked(encrypted_shares, public_coefficients)),\n            \"dispute failed (encrypted shares and/or public coefficients not matching)\"\n        );\n        require(\n            verify_decryption_key(decryption_key, decryption_key_proof, verifier.pk, issuer.pk),\n            \"dispute failed (invalid decryption key or decryption key proof)\"\n        );\n\n        // compute share index i:\n        // the index i is one-based (which is required!) (indepent of the correction below)\n        // as the issuer does not provide a share for itself the index has to be corrected\n        uint256 i = verifier.id;\n        if (i > issuer.id) {\n            i--;\n        }\n\n        // decryption of the share, (correct for one-based index i to make it zero-based)\n        uint256 share = encrypted_shares[i - 1] ^ uint256(keccak256(abi.encodePacked(decryption_key[0], verifier.id)));\n        // require(false, \"test assert here\");\n        \n        // verify that share is actually invalid\n        // evaluate the poly polynom F(x) for x = i\n        uint256 x = i;\n        uint256[2] memory Fx = [ issuer.pk[0], issuer.pk[1] ];\n        uint256[2] memory tmp = bn128_multiply([public_coefficients[0], public_coefficients[1], x]);\n        Fx = bn128_add([Fx[0], Fx[1], tmp[0], tmp[1]]);\n\n        for (uint256 j = 2; j < public_coefficients.length; j += 2) { \n            x = mulmod(x, i, GROUP_ORDER);\n            tmp = bn128_multiply([public_coefficients[j], public_coefficients[j + 1], x]);\n            Fx = bn128_add([Fx[0], Fx[1], tmp[0], tmp[1]]);\n        }\n        // and compare the result (stored in Fx) with g1*si\n        uint256[2] memory Fi = bn128_multiply([g1x, g1y, share]);   \n\n        // require that share is actually invalid\n        require(Fx[0] != Fi[0] || Fx[1] != Fi[1], \"dispute failed (the provided share was valid)\");\n\n        __slash__(issuer_addr);\n    }"
      VariableDeclarationStatement
         Source: "Node storage issuer = nodes[issuer_addr]"
        VariableDeclaration "issuer"
           Type: struct DKG.Node storage pointer
           Source: "Node storage issuer"
          UserDefinedTypeName "Node"
             Source: "Node"
        IndexAccess
           Type: struct DKG.Node storage ref
           Source: "nodes[issuer_addr]"
          Identifier nodes
             Type: mapping(address => struct DKG.Node storage ref)
             Source: "nodes"
          Identifier issuer_addr
             Type: address
             Source: "issuer_addr"
      VariableDeclarationStatement
         Source: "Node storage verifier = nodes[msg.sender]"
        VariableDeclaration "verifier"
           Type: struct DKG.Node storage pointer
           Source: "Node storage verifier"
          UserDefinedTypeName "Node"
             Source: "Node"
        IndexAccess
           Type: struct DKG.Node storage ref
           Source: "nodes[msg.sender]"
          Identifier nodes
             Type: mapping(address => struct DKG.Node storage ref)
             Source: "nodes"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Source: "require(in_dispute_phase(), \"dispute failed (contract is not in sharing phase)\")"
        FunctionCall
           Type: tuple()
           Source: "require(in_dispute_phase(), \"dispute failed (contract is not in sharing phase)\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "in_dispute_phase()"
            Identifier in_dispute_phase
               Type: function () view returns (bool)
               Source: "in_dispute_phase"
          Literal, token: [no token] value: dispute failed (contract is not in sharing phase)
             Type: literal_string "dispute failed (contract is not in sharing phase)"
             Source: "\"dispute failed (contract is not in sharing phase)\""
      ExpressionStatement
         Source: "require(issuer.id > 0, \"dispute failed/aborted (issuer not registered or slashed)\")"
        FunctionCall
           Type: tuple()
           Source: "require(issuer.id > 0, \"dispute failed/aborted (issuer not registered or slashed)\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "issuer.id > 0"
            MemberAccess to member id
               Type: uint256
               Source: "issuer.id"
              Identifier issuer
                 Type: struct DKG.Node storage pointer
                 Source: "issuer"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          Literal, token: [no token] value: dispute failed/aborted (issuer not registered or slashed)
             Type: literal_string "dispute failed/aborted (issuer not registered or slashed)"
             Source: "\"dispute failed/aborted (issuer not registered or slashed)\""
      ExpressionStatement
         Source: "require(verifier.id > 0, \"dispute failed/aborted (verifier not registered or slashed)\")"
        FunctionCall
           Type: tuple()
           Source: "require(verifier.id > 0, \"dispute failed/aborted (verifier not registered or slashed)\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "verifier.id > 0"
            MemberAccess to member id
               Type: uint256
               Source: "verifier.id"
              Identifier verifier
                 Type: struct DKG.Node storage pointer
                 Source: "verifier"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          Literal, token: [no token] value: dispute failed/aborted (verifier not registered or slashed)
             Type: literal_string "dispute failed/aborted (verifier not registered or slashed)"
             Source: "\"dispute failed/aborted (verifier not registered or slashed)\""
      ExpressionStatement
         Source: "require(issuer.id != verifier.id, \"dispute failed (self dispute is not allowed)\")"
        FunctionCall
           Type: tuple()
           Source: "require(issuer.id != verifier.id, \"dispute failed (self dispute is not allowed)\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "issuer.id != verifier.id"
            MemberAccess to member id
               Type: uint256
               Source: "issuer.id"
              Identifier issuer
                 Type: struct DKG.Node storage pointer
                 Source: "issuer"
            MemberAccess to member id
               Type: uint256
               Source: "verifier.id"
              Identifier verifier
                 Type: struct DKG.Node storage pointer
                 Source: "verifier"
          Literal, token: [no token] value: dispute failed (self dispute is not allowed)
             Type: literal_string "dispute failed (self dispute is not allowed)"
             Source: "\"dispute failed (self dispute is not allowed)\""
      ExpressionStatement
         Source: "require(\n            issuer.key_distribution_hash == keccak256(abi.encodePacked(encrypted_shares, public_coefficients)),\n            \"dispute failed (encrypted shares and/or public coefficients not matching)\"\n        )"
        FunctionCall
           Type: tuple()
           Source: "require(\n            issuer.key_distribution_hash == keccak256(abi.encodePacked(encrypted_shares, public_coefficients)),\n            \"dispute failed (encrypted shares and/or public coefficients not matching)\"\n        )"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "issuer.key_distribution_hash == keccak256(abi.encodePacked(encrypted_shares, public_coefficients))"
            MemberAccess to member key_distribution_hash
               Type: bytes32
               Source: "issuer.key_distribution_hash"
              Identifier issuer
                 Type: struct DKG.Node storage pointer
                 Source: "issuer"
            FunctionCall
               Type: bytes32
               Source: "keccak256(abi.encodePacked(encrypted_shares, public_coefficients))"
              Identifier keccak256
                 Type: function () pure returns (bytes32)
                 Source: "keccak256"
              FunctionCall
                 Type: bytes memory
                 Source: "abi.encodePacked(encrypted_shares, public_coefficients)"
                MemberAccess to member encodePacked
                   Type: function () pure returns (bytes memory)
                   Source: "abi.encodePacked"
                  Identifier abi
                     Type: abi
                     Source: "abi"
                Identifier encrypted_shares
                   Type: uint256[] memory
                   Source: "encrypted_shares"
                Identifier public_coefficients
                   Type: uint256[] memory
                   Source: "public_coefficients"
          Literal, token: [no token] value: dispute failed (encrypted shares and/or public coefficients not matching)
             Type: literal_string "dispute failed (encrypted shares and/or public coefficients not matching)"
             Source: "\"dispute failed (encrypted shares and/or public coefficients not matching)\""
      ExpressionStatement
         Source: "require(\n            verify_decryption_key(decryption_key, decryption_key_proof, verifier.pk, issuer.pk),\n            \"dispute failed (invalid decryption key or decryption key proof)\"\n        )"
        FunctionCall
           Type: tuple()
           Source: "require(\n            verify_decryption_key(decryption_key, decryption_key_proof, verifier.pk, issuer.pk),\n            \"dispute failed (invalid decryption key or decryption key proof)\"\n        )"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "verify_decryption_key(decryption_key, decryption_key_proof, verifier.pk, issuer.pk)"
            Identifier verify_decryption_key
               Type: function (uint256[2] memory,uint256[2] memory,uint256[2] memory,uint256[2] memory) returns (bool)
               Source: "verify_decryption_key"
            Identifier decryption_key
               Type: uint256[2] memory
               Source: "decryption_key"
            Identifier decryption_key_proof
               Type: uint256[2] memory
               Source: "decryption_key_proof"
            MemberAccess to member pk
               Type: uint256[2] storage ref
               Source: "verifier.pk"
              Identifier verifier
                 Type: struct DKG.Node storage pointer
                 Source: "verifier"
            MemberAccess to member pk
               Type: uint256[2] storage ref
               Source: "issuer.pk"
              Identifier issuer
                 Type: struct DKG.Node storage pointer
                 Source: "issuer"
          Literal, token: [no token] value: dispute failed (invalid decryption key or decryption key proof)
             Type: literal_string "dispute failed (invalid decryption key or decryption key proof)"
             Source: "\"dispute failed (invalid decryption key or decryption key proof)\""
      VariableDeclarationStatement
         Source: "uint256 i = verifier.id"
        VariableDeclaration "i"
           Type: uint256
           Source: "uint256 i"
          ElementaryTypeName uint256
             Source: "uint256"
        MemberAccess to member id
           Type: uint256
           Source: "verifier.id"
          Identifier verifier
             Type: struct DKG.Node storage pointer
             Source: "verifier"
      IfStatement
         Source: "if (i > issuer.id) {\n            i--;\n        }"
        BinaryOperation using operator >
           Type: bool
           Source: "i > issuer.id"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member id
             Type: uint256
             Source: "issuer.id"
            Identifier issuer
               Type: struct DKG.Node storage pointer
               Source: "issuer"
        Block
           Source: "{\n            i--;\n        }"
          ExpressionStatement
             Source: "i--"
            UnaryOperation (postfix) --
               Type: uint256
               Source: "i--"
              Identifier i
                 Type: uint256
                 Source: "i"
      VariableDeclarationStatement
         Source: "uint256 share = encrypted_shares[i - 1] ^ uint256(keccak256(abi.encodePacked(decryption_key[0], verifier.id)))"
        VariableDeclaration "share"
           Type: uint256
           Source: "uint256 share"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator ^
           Type: uint256
           Source: "encrypted_shares[i - 1] ^ uint256(keccak256(abi.encodePacked(decryption_key[0], verifier.id)))"
          IndexAccess
             Type: uint256
             Source: "encrypted_shares[i - 1]"
            Identifier encrypted_shares
               Type: uint256[] memory
               Source: "encrypted_shares"
            BinaryOperation using operator -
               Type: uint256
               Source: "i - 1"
              Identifier i
                 Type: uint256
                 Source: "i"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
          FunctionCall
             Type: uint256
             Source: "uint256(keccak256(abi.encodePacked(decryption_key[0], verifier.id)))"
            ElementaryTypeNameExpression uint256
               Type: type(uint256)
               Source: "uint256"
            FunctionCall
               Type: bytes32
               Source: "keccak256(abi.encodePacked(decryption_key[0], verifier.id))"
              Identifier keccak256
                 Type: function () pure returns (bytes32)
                 Source: "keccak256"
              FunctionCall
                 Type: bytes memory
                 Source: "abi.encodePacked(decryption_key[0], verifier.id)"
                MemberAccess to member encodePacked
                   Type: function () pure returns (bytes memory)
                   Source: "abi.encodePacked"
                  Identifier abi
                     Type: abi
                     Source: "abi"
                IndexAccess
                   Type: uint256
                   Source: "decryption_key[0]"
                  Identifier decryption_key
                     Type: uint256[2] memory
                     Source: "decryption_key"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
                MemberAccess to member id
                   Type: uint256
                   Source: "verifier.id"
                  Identifier verifier
                     Type: struct DKG.Node storage pointer
                     Source: "verifier"
      VariableDeclarationStatement
         Source: "uint256 x = i"
        VariableDeclaration "x"
           Type: uint256
           Source: "uint256 x"
          ElementaryTypeName uint256
             Source: "uint256"
        Identifier i
           Type: uint256
           Source: "i"
      VariableDeclarationStatement
         Source: "uint256[2] memory Fx = [ issuer.pk[0], issuer.pk[1] ]"
        VariableDeclaration "Fx"
           Type: uint256[2] memory
           Source: "uint256[2] memory Fx"
          ArrayTypeName
             Source: "uint256[2]"
            ElementaryTypeName uint256
               Source: "uint256"
            Literal, token: [no token] value: 2
               Type unknown.
               Source: "2"
        TupleExpression
           Type: uint256[2] memory
           Source: "[ issuer.pk[0], issuer.pk[1] ]"
          IndexAccess
             Type: uint256
             Source: "issuer.pk[0]"
            MemberAccess to member pk
               Type: uint256[2] storage ref
               Source: "issuer.pk"
              Identifier issuer
                 Type: struct DKG.Node storage pointer
                 Source: "issuer"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          IndexAccess
             Type: uint256
             Source: "issuer.pk[1]"
            MemberAccess to member pk
               Type: uint256[2] storage ref
               Source: "issuer.pk"
              Identifier issuer
                 Type: struct DKG.Node storage pointer
                 Source: "issuer"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
      VariableDeclarationStatement
         Source: "uint256[2] memory tmp = bn128_multiply([public_coefficients[0], public_coefficients[1], x])"
        VariableDeclaration "tmp"
           Type: uint256[2] memory
           Source: "uint256[2] memory tmp"
          ArrayTypeName
             Source: "uint256[2]"
            ElementaryTypeName uint256
               Source: "uint256"
            Literal, token: [no token] value: 2
               Type unknown.
               Source: "2"
        FunctionCall
           Type: uint256[2] memory
           Source: "bn128_multiply([public_coefficients[0], public_coefficients[1], x])"
          Identifier bn128_multiply
             Type: function (uint256[3] memory) returns (uint256[2] memory)
             Source: "bn128_multiply"
          TupleExpression
             Type: uint256[3] memory
             Source: "[public_coefficients[0], public_coefficients[1], x]"
            IndexAccess
               Type: uint256
               Source: "public_coefficients[0]"
              Identifier public_coefficients
                 Type: uint256[] memory
                 Source: "public_coefficients"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            IndexAccess
               Type: uint256
               Source: "public_coefficients[1]"
              Identifier public_coefficients
                 Type: uint256[] memory
                 Source: "public_coefficients"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
            Identifier x
               Type: uint256
               Source: "x"
      ExpressionStatement
         Source: "Fx = bn128_add([Fx[0], Fx[1], tmp[0], tmp[1]])"
        Assignment using operator =
           Type: uint256[2] memory
           Source: "Fx = bn128_add([Fx[0], Fx[1], tmp[0], tmp[1]])"
          Identifier Fx
             Type: uint256[2] memory
             Source: "Fx"
          FunctionCall
             Type: uint256[2] memory
             Source: "bn128_add([Fx[0], Fx[1], tmp[0], tmp[1]])"
            Identifier bn128_add
               Type: function (uint256[4] memory) returns (uint256[2] memory)
               Source: "bn128_add"
            TupleExpression
               Type: uint256[4] memory
               Source: "[Fx[0], Fx[1], tmp[0], tmp[1]]"
              IndexAccess
                 Type: uint256
                 Source: "Fx[0]"
                Identifier Fx
                   Type: uint256[2] memory
                   Source: "Fx"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              IndexAccess
                 Type: uint256
                 Source: "Fx[1]"
                Identifier Fx
                   Type: uint256[2] memory
                   Source: "Fx"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
              IndexAccess
                 Type: uint256
                 Source: "tmp[0]"
                Identifier tmp
                   Type: uint256[2] memory
                   Source: "tmp"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              IndexAccess
                 Type: uint256
                 Source: "tmp[1]"
                Identifier tmp
                   Type: uint256[2] memory
                   Source: "tmp"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
      ForStatement
         Source: "for (uint256 j = 2; j < public_coefficients.length; j += 2) { \n            x = mulmod(x, i, GROUP_ORDER);\n            tmp = bn128_multiply([public_coefficients[j], public_coefficients[j + 1], x]);\n            Fx = bn128_add([Fx[0], Fx[1], tmp[0], tmp[1]]);\n        }"
        VariableDeclarationStatement
           Source: "uint256 j = 2"
          VariableDeclaration "j"
             Type: uint256
             Source: "uint256 j"
            ElementaryTypeName uint256
               Source: "uint256"
          Literal, token: [no token] value: 2
             Type: int_const 2
             Source: "2"
        BinaryOperation using operator <
           Type: bool
           Source: "j < public_coefficients.length"
          Identifier j
             Type: uint256
             Source: "j"
          MemberAccess to member length
             Type: uint256
             Source: "public_coefficients.length"
            Identifier public_coefficients
               Type: uint256[] memory
               Source: "public_coefficients"
        ExpressionStatement
           Source: "j += 2"
          Assignment using operator +=
             Type: uint256
             Source: "j += 2"
            Identifier j
               Type: uint256
               Source: "j"
            Literal, token: [no token] value: 2
               Type: int_const 2
               Source: "2"
        Block
           Source: "{ \n            x = mulmod(x, i, GROUP_ORDER);\n            tmp = bn128_multiply([public_coefficients[j], public_coefficients[j + 1], x]);\n            Fx = bn128_add([Fx[0], Fx[1], tmp[0], tmp[1]]);\n        }"
          ExpressionStatement
             Source: "x = mulmod(x, i, GROUP_ORDER)"
            Assignment using operator =
               Type: uint256
               Source: "x = mulmod(x, i, GROUP_ORDER)"
              Identifier x
                 Type: uint256
                 Source: "x"
              FunctionCall
                 Type: uint256
                 Source: "mulmod(x, i, GROUP_ORDER)"
                Identifier mulmod
                   Type: function (uint256,uint256,uint256) pure returns (uint256)
                   Source: "mulmod"
                Identifier x
                   Type: uint256
                   Source: "x"
                Identifier i
                   Type: uint256
                   Source: "i"
                Identifier GROUP_ORDER
                   Type: uint256
                   Source: "GROUP_ORDER"
          ExpressionStatement
             Source: "tmp = bn128_multiply([public_coefficients[j], public_coefficients[j + 1], x])"
            Assignment using operator =
               Type: uint256[2] memory
               Source: "tmp = bn128_multiply([public_coefficients[j], public_coefficients[j + 1], x])"
              Identifier tmp
                 Type: uint256[2] memory
                 Source: "tmp"
              FunctionCall
                 Type: uint256[2] memory
                 Source: "bn128_multiply([public_coefficients[j], public_coefficients[j + 1], x])"
                Identifier bn128_multiply
                   Type: function (uint256[3] memory) returns (uint256[2] memory)
                   Source: "bn128_multiply"
                TupleExpression
                   Type: uint256[3] memory
                   Source: "[public_coefficients[j], public_coefficients[j + 1], x]"
                  IndexAccess
                     Type: uint256
                     Source: "public_coefficients[j]"
                    Identifier public_coefficients
                       Type: uint256[] memory
                       Source: "public_coefficients"
                    Identifier j
                       Type: uint256
                       Source: "j"
                  IndexAccess
                     Type: uint256
                     Source: "public_coefficients[j + 1]"
                    Identifier public_coefficients
                       Type: uint256[] memory
                       Source: "public_coefficients"
                    BinaryOperation using operator +
                       Type: uint256
                       Source: "j + 1"
                      Identifier j
                         Type: uint256
                         Source: "j"
                      Literal, token: [no token] value: 1
                         Type: int_const 1
                         Source: "1"
                  Identifier x
                     Type: uint256
                     Source: "x"
          ExpressionStatement
             Source: "Fx = bn128_add([Fx[0], Fx[1], tmp[0], tmp[1]])"
            Assignment using operator =
               Type: uint256[2] memory
               Source: "Fx = bn128_add([Fx[0], Fx[1], tmp[0], tmp[1]])"
              Identifier Fx
                 Type: uint256[2] memory
                 Source: "Fx"
              FunctionCall
                 Type: uint256[2] memory
                 Source: "bn128_add([Fx[0], Fx[1], tmp[0], tmp[1]])"
                Identifier bn128_add
                   Type: function (uint256[4] memory) returns (uint256[2] memory)
                   Source: "bn128_add"
                TupleExpression
                   Type: uint256[4] memory
                   Source: "[Fx[0], Fx[1], tmp[0], tmp[1]]"
                  IndexAccess
                     Type: uint256
                     Source: "Fx[0]"
                    Identifier Fx
                       Type: uint256[2] memory
                       Source: "Fx"
                    Literal, token: [no token] value: 0
                       Type: int_const 0
                       Source: "0"
                  IndexAccess
                     Type: uint256
                     Source: "Fx[1]"
                    Identifier Fx
                       Type: uint256[2] memory
                       Source: "Fx"
                    Literal, token: [no token] value: 1
                       Type: int_const 1
                       Source: "1"
                  IndexAccess
                     Type: uint256
                     Source: "tmp[0]"
                    Identifier tmp
                       Type: uint256[2] memory
                       Source: "tmp"
                    Literal, token: [no token] value: 0
                       Type: int_const 0
                       Source: "0"
                  IndexAccess
                     Type: uint256
                     Source: "tmp[1]"
                    Identifier tmp
                       Type: uint256[2] memory
                       Source: "tmp"
                    Literal, token: [no token] value: 1
                       Type: int_const 1
                       Source: "1"
      VariableDeclarationStatement
         Source: "uint256[2] memory Fi = bn128_multiply([g1x, g1y, share])"
        VariableDeclaration "Fi"
           Type: uint256[2] memory
           Source: "uint256[2] memory Fi"
          ArrayTypeName
             Source: "uint256[2]"
            ElementaryTypeName uint256
               Source: "uint256"
            Literal, token: [no token] value: 2
               Type unknown.
               Source: "2"
        FunctionCall
           Type: uint256[2] memory
           Source: "bn128_multiply([g1x, g1y, share])"
          Identifier bn128_multiply
             Type: function (uint256[3] memory) returns (uint256[2] memory)
             Source: "bn128_multiply"
          TupleExpression
             Type: uint256[3] memory
             Source: "[g1x, g1y, share]"
            Identifier g1x
               Type: uint256
               Source: "g1x"
            Identifier g1y
               Type: uint256
               Source: "g1y"
            Identifier share
               Type: uint256
               Source: "share"
      ExpressionStatement
         Source: "require(Fx[0] != Fi[0] || Fx[1] != Fi[1], \"dispute failed (the provided share was valid)\")"
        FunctionCall
           Type: tuple()
           Source: "require(Fx[0] != Fi[0] || Fx[1] != Fi[1], \"dispute failed (the provided share was valid)\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          BinaryOperation using operator ||
             Type: bool
             Source: "Fx[0] != Fi[0] || Fx[1] != Fi[1]"
            BinaryOperation using operator !=
               Type: bool
               Source: "Fx[0] != Fi[0]"
              IndexAccess
                 Type: uint256
                 Source: "Fx[0]"
                Identifier Fx
                   Type: uint256[2] memory
                   Source: "Fx"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              IndexAccess
                 Type: uint256
                 Source: "Fi[0]"
                Identifier Fi
                   Type: uint256[2] memory
                   Source: "Fi"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
            BinaryOperation using operator !=
               Type: bool
               Source: "Fx[1] != Fi[1]"
              IndexAccess
                 Type: uint256
                 Source: "Fx[1]"
                Identifier Fx
                   Type: uint256[2] memory
                   Source: "Fx"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
              IndexAccess
                 Type: uint256
                 Source: "Fi[1]"
                Identifier Fi
                   Type: uint256[2] memory
                   Source: "Fi"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
          Literal, token: [no token] value: dispute failed (the provided share was valid)
             Type: literal_string "dispute failed (the provided share was valid)"
             Source: "\"dispute failed (the provided share was valid)\""
      ExpressionStatement
         Source: "__slash__(issuer_addr)"
        FunctionCall
           Type: tuple()
           Source: "__slash__(issuer_addr)"
          Identifier __slash__
             Type: function (address)
             Source: "__slash__"
          Identifier issuer_addr
             Type: address
             Source: "issuer_addr"
  FunctionDefinition "upload_group_key" - public
     Source: "function upload_group_key(uint[4] _bls_group_pk) \n    public returns(bool success)\n    {\n        require(\n            in_finalization_phase(),    \n            \"group key upload failed (key sharing / disputes not finsished, or group key already uploaded)\"\n        );\n\n        uint256 n = registered_addresses.length;\n        uint256 t = (n / 2) + 1;\n        \n        Node memory node;\n        uint256[2] memory group_pk;\n        \n        // find first (i.e. lowest index) valid registered node\n        uint256 i = 0;\n        do {\n            node = nodes[registered_addresses[i]];\n            i += 1;\n        } \n        while((node.id == 0 || node.key_distribution_hash == 0) && i < n);\n\n        if (i == n) {\n            // in this case at most one nodes actually shared a valid key\n            __abort__();\n            return false;\n        }\n        \n        uint256 p = 1;  // number of nodes which provided valid keys\n        group_pk = node.pk;\n        for ( ; i < registered_addresses.length; i++) {  // sum up all valid pubic keys\n            node = nodes[registered_addresses[i]];\n            if (node.id != 0 && node.key_distribution_hash != 0) {\n                p++;\n                group_pk = bn128_add([group_pk[0], group_pk[1], node.pk[0], node.pk[1]]);\n            }\n        }\n\n        if (p < t) {\n            __abort__();\n            return false;\n        }\n\n        // ensures that the given group_pk and bls_group_pk correspond to each other\n        require(\n            bn128_check_pairing(                                    \n                [                       \n                    group_pk[0], group_pk[1],\n                    g2xx, g2xy, g2yx, g2yy,\n                    g1x, g1y,\n                    _bls_group_pk[0], _bls_group_pk[1], _bls_group_pk[2], _bls_group_pk[3]\n                ]), \n            \"upload of group key failed (the submitted bls_group_pk does not correspond to group_pk)\"\n        );\n\n        bls_group_pk = _bls_group_pk;\n        T_GROUP_KEY_UPLOAD = block.number;\n    }"
    ParameterList
       Source: "(uint[4] _bls_group_pk)"
      VariableDeclaration "_bls_group_pk"
         Type: uint256[4] memory
         Source: "uint[4] _bls_group_pk"
        ArrayTypeName
           Source: "uint[4]"
          ElementaryTypeName uint
             Source: "uint"
          Literal, token: [no token] value: 4
             Type unknown.
             Source: "4"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\n        require(\n            in_finalization_phase(),    \n            \"group key upload failed (key sharing / disputes not finsished, or group key already uploaded)\"\n        );\n\n        uint256 n = registered_addresses.length;\n        uint256 t = (n / 2) + 1;\n        \n        Node memory node;\n        uint256[2] memory group_pk;\n        \n        // find first (i.e. lowest index) valid registered node\n        uint256 i = 0;\n        do {\n            node = nodes[registered_addresses[i]];\n            i += 1;\n        } \n        while((node.id == 0 || node.key_distribution_hash == 0) && i < n);\n\n        if (i == n) {\n            // in this case at most one nodes actually shared a valid key\n            __abort__();\n            return false;\n        }\n        \n        uint256 p = 1;  // number of nodes which provided valid keys\n        group_pk = node.pk;\n        for ( ; i < registered_addresses.length; i++) {  // sum up all valid pubic keys\n            node = nodes[registered_addresses[i]];\n            if (node.id != 0 && node.key_distribution_hash != 0) {\n                p++;\n                group_pk = bn128_add([group_pk[0], group_pk[1], node.pk[0], node.pk[1]]);\n            }\n        }\n\n        if (p < t) {\n            __abort__();\n            return false;\n        }\n\n        // ensures that the given group_pk and bls_group_pk correspond to each other\n        require(\n            bn128_check_pairing(                                    \n                [                       \n                    group_pk[0], group_pk[1],\n                    g2xx, g2xy, g2yx, g2yy,\n                    g1x, g1y,\n                    _bls_group_pk[0], _bls_group_pk[1], _bls_group_pk[2], _bls_group_pk[3]\n                ]), \n            \"upload of group key failed (the submitted bls_group_pk does not correspond to group_pk)\"\n        );\n\n        bls_group_pk = _bls_group_pk;\n        T_GROUP_KEY_UPLOAD = block.number;\n    }"
      ExpressionStatement
         Source: "require(\n            in_finalization_phase(),    \n            \"group key upload failed (key sharing / disputes not finsished, or group key already uploaded)\"\n        )"
        FunctionCall
           Type: tuple()
           Source: "require(\n            in_finalization_phase(),    \n            \"group key upload failed (key sharing / disputes not finsished, or group key already uploaded)\"\n        )"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "in_finalization_phase()"
            Identifier in_finalization_phase
               Type: function () view returns (bool)
               Source: "in_finalization_phase"
          Literal, token: [no token] value: group key upload failed (key sharing / disputes not finsished, or group key already uploaded)
             Type: literal_string "group key upload failed (key sharing / disputes not finsished, or group key already uploaded)"
             Source: "\"group key upload failed (key sharing / disputes not finsished, or group key already uploaded)\""
      VariableDeclarationStatement
         Source: "uint256 n = registered_addresses.length"
        VariableDeclaration "n"
           Type: uint256
           Source: "uint256 n"
          ElementaryTypeName uint256
             Source: "uint256"
        MemberAccess to member length
           Type: uint256
           Source: "registered_addresses.length"
          Identifier registered_addresses
             Type: address[] storage ref
             Source: "registered_addresses"
      VariableDeclarationStatement
         Source: "uint256 t = (n / 2) + 1"
        VariableDeclaration "t"
           Type: uint256
           Source: "uint256 t"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator +
           Type: uint256
           Source: "(n / 2) + 1"
          TupleExpression
             Type: uint256
             Source: "(n / 2)"
            BinaryOperation using operator /
               Type: uint256
               Source: "n / 2"
              Identifier n
                 Type: uint256
                 Source: "n"
              Literal, token: [no token] value: 2
                 Type: int_const 2
                 Source: "2"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
      VariableDeclarationStatement
         Source: "Node memory node"
        VariableDeclaration "node"
           Type: struct DKG.Node memory
           Source: "Node memory node"
          UserDefinedTypeName "Node"
             Source: "Node"
      VariableDeclarationStatement
         Source: "uint256[2] memory group_pk"
        VariableDeclaration "group_pk"
           Type: uint256[2] memory
           Source: "uint256[2] memory group_pk"
          ArrayTypeName
             Source: "uint256[2]"
            ElementaryTypeName uint256
               Source: "uint256"
            Literal, token: [no token] value: 2
               Type unknown.
               Source: "2"
      VariableDeclarationStatement
         Source: "uint256 i = 0"
        VariableDeclaration "i"
           Type: uint256
           Source: "uint256 i"
          ElementaryTypeName uint256
             Source: "uint256"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      DoWhileStatement
         Source: "do {\n            node = nodes[registered_addresses[i]];\n            i += 1;\n        } \n        while((node.id == 0 || node.key_distribution_hash == 0) && i < n);"
        BinaryOperation using operator &&
           Type: bool
           Source: "(node.id == 0 || node.key_distribution_hash == 0) && i < n"
          TupleExpression
             Type: bool
             Source: "(node.id == 0 || node.key_distribution_hash == 0)"
            BinaryOperation using operator ||
               Type: bool
               Source: "node.id == 0 || node.key_distribution_hash == 0"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "node.id == 0"
                MemberAccess to member id
                   Type: uint256
                   Source: "node.id"
                  Identifier node
                     Type: struct DKG.Node memory
                     Source: "node"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "node.key_distribution_hash == 0"
                MemberAccess to member key_distribution_hash
                   Type: bytes32
                   Source: "node.key_distribution_hash"
                  Identifier node
                     Type: struct DKG.Node memory
                     Source: "node"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
          BinaryOperation using operator <
             Type: bool
             Source: "i < n"
            Identifier i
               Type: uint256
               Source: "i"
            Identifier n
               Type: uint256
               Source: "n"
        Block
           Source: "{\n            node = nodes[registered_addresses[i]];\n            i += 1;\n        }"
          ExpressionStatement
             Source: "node = nodes[registered_addresses[i]]"
            Assignment using operator =
               Type: struct DKG.Node memory
               Source: "node = nodes[registered_addresses[i]]"
              Identifier node
                 Type: struct DKG.Node memory
                 Source: "node"
              IndexAccess
                 Type: struct DKG.Node storage ref
                 Source: "nodes[registered_addresses[i]]"
                Identifier nodes
                   Type: mapping(address => struct DKG.Node storage ref)
                   Source: "nodes"
                IndexAccess
                   Type: address
                   Source: "registered_addresses[i]"
                  Identifier registered_addresses
                     Type: address[] storage ref
                     Source: "registered_addresses"
                  Identifier i
                     Type: uint256
                     Source: "i"
          ExpressionStatement
             Source: "i += 1"
            Assignment using operator +=
               Type: uint256
               Source: "i += 1"
              Identifier i
                 Type: uint256
                 Source: "i"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
      IfStatement
         Source: "if (i == n) {\n            // in this case at most one nodes actually shared a valid key\n            __abort__();\n            return false;\n        }"
        BinaryOperation using operator ==
           Type: bool
           Source: "i == n"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier n
             Type: uint256
             Source: "n"
        Block
           Source: "{\n            // in this case at most one nodes actually shared a valid key\n            __abort__();\n            return false;\n        }"
          ExpressionStatement
             Source: "__abort__()"
            FunctionCall
               Type: tuple()
               Source: "__abort__()"
              Identifier __abort__
                 Type: function ()
                 Source: "__abort__"
          Return
             Source: "return false"
            Literal, token: false value: false
               Type: bool
               Source: "false"
      VariableDeclarationStatement
         Source: "uint256 p = 1"
        VariableDeclaration "p"
           Type: uint256
           Source: "uint256 p"
          ElementaryTypeName uint256
             Source: "uint256"
        Literal, token: [no token] value: 1
           Type: int_const 1
           Source: "1"
      ExpressionStatement
         Source: "group_pk = node.pk"
        Assignment using operator =
           Type: uint256[2] memory
           Source: "group_pk = node.pk"
          Identifier group_pk
             Type: uint256[2] memory
             Source: "group_pk"
          MemberAccess to member pk
             Type: uint256[2] memory
             Source: "node.pk"
            Identifier node
               Type: struct DKG.Node memory
               Source: "node"
      ForStatement
         Source: "for ( ; i < registered_addresses.length; i++) {  // sum up all valid pubic keys\n            node = nodes[registered_addresses[i]];\n            if (node.id != 0 && node.key_distribution_hash != 0) {\n                p++;\n                group_pk = bn128_add([group_pk[0], group_pk[1], node.pk[0], node.pk[1]]);\n            }\n        }"
        BinaryOperation using operator <
           Type: bool
           Source: "i < registered_addresses.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "registered_addresses.length"
            Identifier registered_addresses
               Type: address[] storage ref
               Source: "registered_addresses"
        ExpressionStatement
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{  // sum up all valid pubic keys\n            node = nodes[registered_addresses[i]];\n            if (node.id != 0 && node.key_distribution_hash != 0) {\n                p++;\n                group_pk = bn128_add([group_pk[0], group_pk[1], node.pk[0], node.pk[1]]);\n            }\n        }"
          ExpressionStatement
             Source: "node = nodes[registered_addresses[i]]"
            Assignment using operator =
               Type: struct DKG.Node memory
               Source: "node = nodes[registered_addresses[i]]"
              Identifier node
                 Type: struct DKG.Node memory
                 Source: "node"
              IndexAccess
                 Type: struct DKG.Node storage ref
                 Source: "nodes[registered_addresses[i]]"
                Identifier nodes
                   Type: mapping(address => struct DKG.Node storage ref)
                   Source: "nodes"
                IndexAccess
                   Type: address
                   Source: "registered_addresses[i]"
                  Identifier registered_addresses
                     Type: address[] storage ref
                     Source: "registered_addresses"
                  Identifier i
                     Type: uint256
                     Source: "i"
          IfStatement
             Source: "if (node.id != 0 && node.key_distribution_hash != 0) {\n                p++;\n                group_pk = bn128_add([group_pk[0], group_pk[1], node.pk[0], node.pk[1]]);\n            }"
            BinaryOperation using operator &&
               Type: bool
               Source: "node.id != 0 && node.key_distribution_hash != 0"
              BinaryOperation using operator !=
                 Type: bool
                 Source: "node.id != 0"
                MemberAccess to member id
                   Type: uint256
                   Source: "node.id"
                  Identifier node
                     Type: struct DKG.Node memory
                     Source: "node"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              BinaryOperation using operator !=
                 Type: bool
                 Source: "node.key_distribution_hash != 0"
                MemberAccess to member key_distribution_hash
                   Type: bytes32
                   Source: "node.key_distribution_hash"
                  Identifier node
                     Type: struct DKG.Node memory
                     Source: "node"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
            Block
               Source: "{\n                p++;\n                group_pk = bn128_add([group_pk[0], group_pk[1], node.pk[0], node.pk[1]]);\n            }"
              ExpressionStatement
                 Source: "p++"
                UnaryOperation (postfix) ++
                   Type: uint256
                   Source: "p++"
                  Identifier p
                     Type: uint256
                     Source: "p"
              ExpressionStatement
                 Source: "group_pk = bn128_add([group_pk[0], group_pk[1], node.pk[0], node.pk[1]])"
                Assignment using operator =
                   Type: uint256[2] memory
                   Source: "group_pk = bn128_add([group_pk[0], group_pk[1], node.pk[0], node.pk[1]])"
                  Identifier group_pk
                     Type: uint256[2] memory
                     Source: "group_pk"
                  FunctionCall
                     Type: uint256[2] memory
                     Source: "bn128_add([group_pk[0], group_pk[1], node.pk[0], node.pk[1]])"
                    Identifier bn128_add
                       Type: function (uint256[4] memory) returns (uint256[2] memory)
                       Source: "bn128_add"
                    TupleExpression
                       Type: uint256[4] memory
                       Source: "[group_pk[0], group_pk[1], node.pk[0], node.pk[1]]"
                      IndexAccess
                         Type: uint256
                         Source: "group_pk[0]"
                        Identifier group_pk
                           Type: uint256[2] memory
                           Source: "group_pk"
                        Literal, token: [no token] value: 0
                           Type: int_const 0
                           Source: "0"
                      IndexAccess
                         Type: uint256
                         Source: "group_pk[1]"
                        Identifier group_pk
                           Type: uint256[2] memory
                           Source: "group_pk"
                        Literal, token: [no token] value: 1
                           Type: int_const 1
                           Source: "1"
                      IndexAccess
                         Type: uint256
                         Source: "node.pk[0]"
                        MemberAccess to member pk
                           Type: uint256[2] memory
                           Source: "node.pk"
                          Identifier node
                             Type: struct DKG.Node memory
                             Source: "node"
                        Literal, token: [no token] value: 0
                           Type: int_const 0
                           Source: "0"
                      IndexAccess
                         Type: uint256
                         Source: "node.pk[1]"
                        MemberAccess to member pk
                           Type: uint256[2] memory
                           Source: "node.pk"
                          Identifier node
                             Type: struct DKG.Node memory
                             Source: "node"
                        Literal, token: [no token] value: 1
                           Type: int_const 1
                           Source: "1"
      IfStatement
         Source: "if (p < t) {\n            __abort__();\n            return false;\n        }"
        BinaryOperation using operator <
           Type: bool
           Source: "p < t"
          Identifier p
             Type: uint256
             Source: "p"
          Identifier t
             Type: uint256
             Source: "t"
        Block
           Source: "{\n            __abort__();\n            return false;\n        }"
          ExpressionStatement
             Source: "__abort__()"
            FunctionCall
               Type: tuple()
               Source: "__abort__()"
              Identifier __abort__
                 Type: function ()
                 Source: "__abort__"
          Return
             Source: "return false"
            Literal, token: false value: false
               Type: bool
               Source: "false"
      ExpressionStatement
         Source: "require(\n            bn128_check_pairing(                                    \n                [                       \n                    group_pk[0], group_pk[1],\n                    g2xx, g2xy, g2yx, g2yy,\n                    g1x, g1y,\n                    _bls_group_pk[0], _bls_group_pk[1], _bls_group_pk[2], _bls_group_pk[3]\n                ]), \n            \"upload of group key failed (the submitted bls_group_pk does not correspond to group_pk)\"\n        )"
        FunctionCall
           Type: tuple()
           Source: "require(\n            bn128_check_pairing(                                    \n                [                       \n                    group_pk[0], group_pk[1],\n                    g2xx, g2xy, g2yx, g2yy,\n                    g1x, g1y,\n                    _bls_group_pk[0], _bls_group_pk[1], _bls_group_pk[2], _bls_group_pk[3]\n                ]), \n            \"upload of group key failed (the submitted bls_group_pk does not correspond to group_pk)\"\n        )"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "bn128_check_pairing(                                    \n                [                       \n                    group_pk[0], group_pk[1],\n                    g2xx, g2xy, g2yx, g2yy,\n                    g1x, g1y,\n                    _bls_group_pk[0], _bls_group_pk[1], _bls_group_pk[2], _bls_group_pk[3]\n                ])"
            Identifier bn128_check_pairing
               Type: function (uint256[12] memory) returns (bool)
               Source: "bn128_check_pairing"
            TupleExpression
               Type: uint256[12] memory
               Source: "[                       \n                    group_pk[0], group_pk[1],\n                    g2xx, g2xy, g2yx, g2yy,\n                    g1x, g1y,\n                    _bls_group_pk[0], _bls_group_pk[1], _bls_group_pk[2], _bls_group_pk[3]\n                ]"
              IndexAccess
                 Type: uint256
                 Source: "group_pk[0]"
                Identifier group_pk
                   Type: uint256[2] memory
                   Source: "group_pk"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              IndexAccess
                 Type: uint256
                 Source: "group_pk[1]"
                Identifier group_pk
                   Type: uint256[2] memory
                   Source: "group_pk"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
              Identifier g2xx
                 Type: uint256
                 Source: "g2xx"
              Identifier g2xy
                 Type: uint256
                 Source: "g2xy"
              Identifier g2yx
                 Type: uint256
                 Source: "g2yx"
              Identifier g2yy
                 Type: uint256
                 Source: "g2yy"
              Identifier g1x
                 Type: uint256
                 Source: "g1x"
              Identifier g1y
                 Type: uint256
                 Source: "g1y"
              IndexAccess
                 Type: uint256
                 Source: "_bls_group_pk[0]"
                Identifier _bls_group_pk
                   Type: uint256[4] memory
                   Source: "_bls_group_pk"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              IndexAccess
                 Type: uint256
                 Source: "_bls_group_pk[1]"
                Identifier _bls_group_pk
                   Type: uint256[4] memory
                   Source: "_bls_group_pk"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
              IndexAccess
                 Type: uint256
                 Source: "_bls_group_pk[2]"
                Identifier _bls_group_pk
                   Type: uint256[4] memory
                   Source: "_bls_group_pk"
                Literal, token: [no token] value: 2
                   Type: int_const 2
                   Source: "2"
              IndexAccess
                 Type: uint256
                 Source: "_bls_group_pk[3]"
                Identifier _bls_group_pk
                   Type: uint256[4] memory
                   Source: "_bls_group_pk"
                Literal, token: [no token] value: 3
                   Type: int_const 3
                   Source: "3"
          Literal, token: [no token] value: upload of group key failed (the submitted bls_group_pk does not correspond to group_pk)
             Type: literal_string "upload of group key failed (the submitted bls_group_pk does not correspond to group_pk)"
             Source: "\"upload of group key failed (the submitted bls_group_pk does not correspond to group_pk)\""
      ExpressionStatement
         Source: "bls_group_pk = _bls_group_pk"
        Assignment using operator =
           Type: uint256[4] storage ref
           Source: "bls_group_pk = _bls_group_pk"
          Identifier bls_group_pk
             Type: uint256[4] storage ref
             Source: "bls_group_pk"
          Identifier _bls_group_pk
             Type: uint256[4] memory
             Source: "_bls_group_pk"
      ExpressionStatement
         Source: "T_GROUP_KEY_UPLOAD = block.number"
        Assignment using operator =
           Type: uint256
           Source: "T_GROUP_KEY_UPLOAD = block.number"
          Identifier T_GROUP_KEY_UPLOAD
             Type: uint256
             Source: "T_GROUP_KEY_UPLOAD"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
  FunctionDefinition "__slash__"
     Source: "function __slash__(address addr) \n    private \n    {\n        emit DisputeSuccessful(addr);\n        nodes[addr].id = 0;\n    }"
    ParameterList
       Source: "(address addr)"
      VariableDeclaration "addr"
         Type: address
         Source: "address addr"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: ""
    Block
       Source: "{\n        emit DisputeSuccessful(addr);\n        nodes[addr].id = 0;\n    }"
      EmitStatement
         Source: "emit DisputeSuccessful(addr)"
        FunctionCall
           Type: tuple()
           Source: "DisputeSuccessful(addr)"
          Identifier DisputeSuccessful
             Type: function (address)
             Source: "DisputeSuccessful"
          Identifier addr
             Type: address
             Source: "addr"
      ExpressionStatement
         Source: "nodes[addr].id = 0"
        Assignment using operator =
           Type: uint256
           Source: "nodes[addr].id = 0"
          MemberAccess to member id
             Type: uint256
             Source: "nodes[addr].id"
            IndexAccess
               Type: struct DKG.Node storage ref
               Source: "nodes[addr]"
              Identifier nodes
                 Type: mapping(address => struct DKG.Node storage ref)
                 Source: "nodes"
              Identifier addr
                 Type: address
                 Source: "addr"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
  FunctionDefinition "abort" - public
     Source: "function abort() \n    public \n    {\n        // never abort during registration phase\n        require(!in_registration_phase(), \"abort failed (cannot abort during registration phase)\");\n\n        uint256 n = registered_addresses.length;\n        uint256 t = (n / 2) + 1;\n\n        // abort is possible if not enough nodes joined the DKG protocol\n        if (n < PARTICIPATION_THRESHOLD) {\n            __abort__();\n        }\n\n        // abort is possible if less then t nodes actually shared their keys without disputes\n        else {\n            require(\n                T_SHARING_END < block.number, \n                \"abort failed (abort is only possible after key sharing phase ended)\"\n            );\n            uint256 p = 0;  // number of nodes with shared their key without disputes\n            for (uint256 i = 0; i < n; i++) {\n                Node memory node = nodes[registered_addresses[i]];\n\n                // id != 0 ensures not was not slashed\n                // hashkey_distribution_hash != 0 ensures that node has shared its key\n                if ((node.id != 0) && node.key_distribution_hash != 0)  {\n                    p++;\n                }                \n            }\n            require(\n                p < t,\n                \"abort failed (abort is only possible if less than t nodes shared their key successfully)\"\n            );\n            __abort__();\n        }\n    }"
    ParameterList
       Source: "()"
    ParameterList
       Source: ""
    Block
       Source: "{\n        // never abort during registration phase\n        require(!in_registration_phase(), \"abort failed (cannot abort during registration phase)\");\n\n        uint256 n = registered_addresses.length;\n        uint256 t = (n / 2) + 1;\n\n        // abort is possible if not enough nodes joined the DKG protocol\n        if (n < PARTICIPATION_THRESHOLD) {\n            __abort__();\n        }\n\n        // abort is possible if less then t nodes actually shared their keys without disputes\n        else {\n            require(\n                T_SHARING_END < block.number, \n                \"abort failed (abort is only possible after key sharing phase ended)\"\n            );\n            uint256 p = 0;  // number of nodes with shared their key without disputes\n            for (uint256 i = 0; i < n; i++) {\n                Node memory node = nodes[registered_addresses[i]];\n\n                // id != 0 ensures not was not slashed\n                // hashkey_distribution_hash != 0 ensures that node has shared its key\n                if ((node.id != 0) && node.key_distribution_hash != 0)  {\n                    p++;\n                }                \n            }\n            require(\n                p < t,\n                \"abort failed (abort is only possible if less than t nodes shared their key successfully)\"\n            );\n            __abort__();\n        }\n    }"
      ExpressionStatement
         Source: "require(!in_registration_phase(), \"abort failed (cannot abort during registration phase)\")"
        FunctionCall
           Type: tuple()
           Source: "require(!in_registration_phase(), \"abort failed (cannot abort during registration phase)\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!in_registration_phase()"
            FunctionCall
               Type: bool
               Source: "in_registration_phase()"
              Identifier in_registration_phase
                 Type: function () view returns (bool)
                 Source: "in_registration_phase"
          Literal, token: [no token] value: abort failed (cannot abort during registration phase)
             Type: literal_string "abort failed (cannot abort during registration phase)"
             Source: "\"abort failed (cannot abort during registration phase)\""
      VariableDeclarationStatement
         Source: "uint256 n = registered_addresses.length"
        VariableDeclaration "n"
           Type: uint256
           Source: "uint256 n"
          ElementaryTypeName uint256
             Source: "uint256"
        MemberAccess to member length
           Type: uint256
           Source: "registered_addresses.length"
          Identifier registered_addresses
             Type: address[] storage ref
             Source: "registered_addresses"
      VariableDeclarationStatement
         Source: "uint256 t = (n / 2) + 1"
        VariableDeclaration "t"
           Type: uint256
           Source: "uint256 t"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator +
           Type: uint256
           Source: "(n / 2) + 1"
          TupleExpression
             Type: uint256
             Source: "(n / 2)"
            BinaryOperation using operator /
               Type: uint256
               Source: "n / 2"
              Identifier n
                 Type: uint256
                 Source: "n"
              Literal, token: [no token] value: 2
                 Type: int_const 2
                 Source: "2"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
      IfStatement
         Source: "if (n < PARTICIPATION_THRESHOLD) {\n            __abort__();\n        }\n\n        // abort is possible if less then t nodes actually shared their keys without disputes\n        else {\n            require(\n                T_SHARING_END < block.number, \n                \"abort failed (abort is only possible after key sharing phase ended)\"\n            );\n            uint256 p = 0;  // number of nodes with shared their key without disputes\n            for (uint256 i = 0; i < n; i++) {\n                Node memory node = nodes[registered_addresses[i]];\n\n                // id != 0 ensures not was not slashed\n                // hashkey_distribution_hash != 0 ensures that node has shared its key\n                if ((node.id != 0) && node.key_distribution_hash != 0)  {\n                    p++;\n                }                \n            }\n            require(\n                p < t,\n                \"abort failed (abort is only possible if less than t nodes shared their key successfully)\"\n            );\n            __abort__();\n        }"
        BinaryOperation using operator <
           Type: bool
           Source: "n < PARTICIPATION_THRESHOLD"
          Identifier n
             Type: uint256
             Source: "n"
          Identifier PARTICIPATION_THRESHOLD
             Type: uint256
             Source: "PARTICIPATION_THRESHOLD"
        Block
           Source: "{\n            __abort__();\n        }"
          ExpressionStatement
             Source: "__abort__()"
            FunctionCall
               Type: tuple()
               Source: "__abort__()"
              Identifier __abort__
                 Type: function ()
                 Source: "__abort__"
        Block
           Source: "{\n            require(\n                T_SHARING_END < block.number, \n                \"abort failed (abort is only possible after key sharing phase ended)\"\n            );\n            uint256 p = 0;  // number of nodes with shared their key without disputes\n            for (uint256 i = 0; i < n; i++) {\n                Node memory node = nodes[registered_addresses[i]];\n\n                // id != 0 ensures not was not slashed\n                // hashkey_distribution_hash != 0 ensures that node has shared its key\n                if ((node.id != 0) && node.key_distribution_hash != 0)  {\n                    p++;\n                }                \n            }\n            require(\n                p < t,\n                \"abort failed (abort is only possible if less than t nodes shared their key successfully)\"\n            );\n            __abort__();\n        }"
          ExpressionStatement
             Source: "require(\n                T_SHARING_END < block.number, \n                \"abort failed (abort is only possible after key sharing phase ended)\"\n            )"
            FunctionCall
               Type: tuple()
               Source: "require(\n                T_SHARING_END < block.number, \n                \"abort failed (abort is only possible after key sharing phase ended)\"\n            )"
              Identifier require
                 Type: function (bool,string memory) pure
                 Source: "require"
              BinaryOperation using operator <
                 Type: bool
                 Source: "T_SHARING_END < block.number"
                Identifier T_SHARING_END
                   Type: uint256
                   Source: "T_SHARING_END"
                MemberAccess to member number
                   Type: uint256
                   Source: "block.number"
                  Identifier block
                     Type: block
                     Source: "block"
              Literal, token: [no token] value: abort failed (abort is only possible after key sharing phase ended)
                 Type: literal_string "abort failed (abort is only possible after key sharing phase ended)"
                 Source: "\"abort failed (abort is only possible after key sharing phase ended)\""
          VariableDeclarationStatement
             Source: "uint256 p = 0"
            VariableDeclaration "p"
               Type: uint256
               Source: "uint256 p"
              ElementaryTypeName uint256
                 Source: "uint256"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          ForStatement
             Source: "for (uint256 i = 0; i < n; i++) {\n                Node memory node = nodes[registered_addresses[i]];\n\n                // id != 0 ensures not was not slashed\n                // hashkey_distribution_hash != 0 ensures that node has shared its key\n                if ((node.id != 0) && node.key_distribution_hash != 0)  {\n                    p++;\n                }                \n            }"
            VariableDeclarationStatement
               Source: "uint256 i = 0"
              VariableDeclaration "i"
                 Type: uint256
                 Source: "uint256 i"
                ElementaryTypeName uint256
                   Source: "uint256"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            BinaryOperation using operator <
               Type: bool
               Source: "i < n"
              Identifier i
                 Type: uint256
                 Source: "i"
              Identifier n
                 Type: uint256
                 Source: "n"
            ExpressionStatement
               Source: "i++"
              UnaryOperation (postfix) ++
                 Type: uint256
                 Source: "i++"
                Identifier i
                   Type: uint256
                   Source: "i"
            Block
               Source: "{\n                Node memory node = nodes[registered_addresses[i]];\n\n                // id != 0 ensures not was not slashed\n                // hashkey_distribution_hash != 0 ensures that node has shared its key\n                if ((node.id != 0) && node.key_distribution_hash != 0)  {\n                    p++;\n                }                \n            }"
              VariableDeclarationStatement
                 Source: "Node memory node = nodes[registered_addresses[i]]"
                VariableDeclaration "node"
                   Type: struct DKG.Node memory
                   Source: "Node memory node"
                  UserDefinedTypeName "Node"
                     Source: "Node"
                IndexAccess
                   Type: struct DKG.Node storage ref
                   Source: "nodes[registered_addresses[i]]"
                  Identifier nodes
                     Type: mapping(address => struct DKG.Node storage ref)
                     Source: "nodes"
                  IndexAccess
                     Type: address
                     Source: "registered_addresses[i]"
                    Identifier registered_addresses
                       Type: address[] storage ref
                       Source: "registered_addresses"
                    Identifier i
                       Type: uint256
                       Source: "i"
              IfStatement
                 Source: "if ((node.id != 0) && node.key_distribution_hash != 0)  {\n                    p++;\n                }"
                BinaryOperation using operator &&
                   Type: bool
                   Source: "(node.id != 0) && node.key_distribution_hash != 0"
                  TupleExpression
                     Type: bool
                     Source: "(node.id != 0)"
                    BinaryOperation using operator !=
                       Type: bool
                       Source: "node.id != 0"
                      MemberAccess to member id
                         Type: uint256
                         Source: "node.id"
                        Identifier node
                           Type: struct DKG.Node memory
                           Source: "node"
                      Literal, token: [no token] value: 0
                         Type: int_const 0
                         Source: "0"
                  BinaryOperation using operator !=
                     Type: bool
                     Source: "node.key_distribution_hash != 0"
                    MemberAccess to member key_distribution_hash
                       Type: bytes32
                       Source: "node.key_distribution_hash"
                      Identifier node
                         Type: struct DKG.Node memory
                         Source: "node"
                    Literal, token: [no token] value: 0
                       Type: int_const 0
                       Source: "0"
                Block
                   Source: "{\n                    p++;\n                }"
                  ExpressionStatement
                     Source: "p++"
                    UnaryOperation (postfix) ++
                       Type: uint256
                       Source: "p++"
                      Identifier p
                         Type: uint256
                         Source: "p"
          ExpressionStatement
             Source: "require(\n                p < t,\n                \"abort failed (abort is only possible if less than t nodes shared their key successfully)\"\n            )"
            FunctionCall
               Type: tuple()
               Source: "require(\n                p < t,\n                \"abort failed (abort is only possible if less than t nodes shared their key successfully)\"\n            )"
              Identifier require
                 Type: function (bool,string memory) pure
                 Source: "require"
              BinaryOperation using operator <
                 Type: bool
                 Source: "p < t"
                Identifier p
                   Type: uint256
                   Source: "p"
                Identifier t
                   Type: uint256
                   Source: "t"
              Literal, token: [no token] value: abort failed (abort is only possible if less than t nodes shared their key successfully)
                 Type: literal_string "abort failed (abort is only possible if less than t nodes shared their key successfully)"
                 Source: "\"abort failed (abort is only possible if less than t nodes shared their key successfully)\""
          ExpressionStatement
             Source: "__abort__()"
            FunctionCall
               Type: tuple()
               Source: "__abort__()"
              Identifier __abort__
                 Type: function ()
                 Source: "__abort__"
  FunctionDefinition "__abort__"
     Source: "function __abort__() \n    private \n    {\n        // TODO\n        aborted = true;\n    }"
    ParameterList
       Source: "()"
    ParameterList
       Source: ""
    Block
       Source: "{\n        // TODO\n        aborted = true;\n    }"
      ExpressionStatement
         Source: "aborted = true"
        Assignment using operator =
           Type: bool
           Source: "aborted = true"
          Identifier aborted
             Type: bool
             Source: "aborted"
          Literal, token: true value: true
             Type: bool
             Source: "true"
  FunctionDefinition "verify_sk_knowledge" - public
     Source: "function verify_sk_knowledge(uint[2] public_key, uint[2] proof) \n    public returns (bool)\n    {\n        uint256[2] memory a = bn128_multiply([g1x, g1y, proof[1]]);\n        uint256[2] memory b = bn128_multiply([public_key[0], public_key[1], proof[0]]);\n        uint256[2] memory t = bn128_add([a[0], a[1], b[0], b[1]]);\n        \n        uint256 c = uint256(\n            keccak256(abi.encodePacked(g1x, g1y, public_key[0], public_key[1], t[0], t[1], msg.sender)));\n\n        return proof[0] == c;\n    }"
    ParameterList
       Source: "(uint[2] public_key, uint[2] proof)"
      VariableDeclaration "public_key"
         Type: uint256[2] memory
         Source: "uint[2] public_key"
        ArrayTypeName
           Source: "uint[2]"
          ElementaryTypeName uint
             Source: "uint"
          Literal, token: [no token] value: 2
             Type unknown.
             Source: "2"
      VariableDeclaration "proof"
         Type: uint256[2] memory
         Source: "uint[2] proof"
        ArrayTypeName
           Source: "uint[2]"
          ElementaryTypeName uint
             Source: "uint"
          Literal, token: [no token] value: 2
             Type unknown.
             Source: "2"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\n        uint256[2] memory a = bn128_multiply([g1x, g1y, proof[1]]);\n        uint256[2] memory b = bn128_multiply([public_key[0], public_key[1], proof[0]]);\n        uint256[2] memory t = bn128_add([a[0], a[1], b[0], b[1]]);\n        \n        uint256 c = uint256(\n            keccak256(abi.encodePacked(g1x, g1y, public_key[0], public_key[1], t[0], t[1], msg.sender)));\n\n        return proof[0] == c;\n    }"
      VariableDeclarationStatement
         Source: "uint256[2] memory a = bn128_multiply([g1x, g1y, proof[1]])"
        VariableDeclaration "a"
           Type: uint256[2] memory
           Source: "uint256[2] memory a"
          ArrayTypeName
             Source: "uint256[2]"
            ElementaryTypeName uint256
               Source: "uint256"
            Literal, token: [no token] value: 2
               Type unknown.
               Source: "2"
        FunctionCall
           Type: uint256[2] memory
           Source: "bn128_multiply([g1x, g1y, proof[1]])"
          Identifier bn128_multiply
             Type: function (uint256[3] memory) returns (uint256[2] memory)
             Source: "bn128_multiply"
          TupleExpression
             Type: uint256[3] memory
             Source: "[g1x, g1y, proof[1]]"
            Identifier g1x
               Type: uint256
               Source: "g1x"
            Identifier g1y
               Type: uint256
               Source: "g1y"
            IndexAccess
               Type: uint256
               Source: "proof[1]"
              Identifier proof
                 Type: uint256[2] memory
                 Source: "proof"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
      VariableDeclarationStatement
         Source: "uint256[2] memory b = bn128_multiply([public_key[0], public_key[1], proof[0]])"
        VariableDeclaration "b"
           Type: uint256[2] memory
           Source: "uint256[2] memory b"
          ArrayTypeName
             Source: "uint256[2]"
            ElementaryTypeName uint256
               Source: "uint256"
            Literal, token: [no token] value: 2
               Type unknown.
               Source: "2"
        FunctionCall
           Type: uint256[2] memory
           Source: "bn128_multiply([public_key[0], public_key[1], proof[0]])"
          Identifier bn128_multiply
             Type: function (uint256[3] memory) returns (uint256[2] memory)
             Source: "bn128_multiply"
          TupleExpression
             Type: uint256[3] memory
             Source: "[public_key[0], public_key[1], proof[0]]"
            IndexAccess
               Type: uint256
               Source: "public_key[0]"
              Identifier public_key
                 Type: uint256[2] memory
                 Source: "public_key"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            IndexAccess
               Type: uint256
               Source: "public_key[1]"
              Identifier public_key
                 Type: uint256[2] memory
                 Source: "public_key"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
            IndexAccess
               Type: uint256
               Source: "proof[0]"
              Identifier proof
                 Type: uint256[2] memory
                 Source: "proof"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      VariableDeclarationStatement
         Source: "uint256[2] memory t = bn128_add([a[0], a[1], b[0], b[1]])"
        VariableDeclaration "t"
           Type: uint256[2] memory
           Source: "uint256[2] memory t"
          ArrayTypeName
             Source: "uint256[2]"
            ElementaryTypeName uint256
               Source: "uint256"
            Literal, token: [no token] value: 2
               Type unknown.
               Source: "2"
        FunctionCall
           Type: uint256[2] memory
           Source: "bn128_add([a[0], a[1], b[0], b[1]])"
          Identifier bn128_add
             Type: function (uint256[4] memory) returns (uint256[2] memory)
             Source: "bn128_add"
          TupleExpression
             Type: uint256[4] memory
             Source: "[a[0], a[1], b[0], b[1]]"
            IndexAccess
               Type: uint256
               Source: "a[0]"
              Identifier a
                 Type: uint256[2] memory
                 Source: "a"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            IndexAccess
               Type: uint256
               Source: "a[1]"
              Identifier a
                 Type: uint256[2] memory
                 Source: "a"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
            IndexAccess
               Type: uint256
               Source: "b[0]"
              Identifier b
                 Type: uint256[2] memory
                 Source: "b"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            IndexAccess
               Type: uint256
               Source: "b[1]"
              Identifier b
                 Type: uint256[2] memory
                 Source: "b"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
      VariableDeclarationStatement
         Source: "uint256 c = uint256(\n            keccak256(abi.encodePacked(g1x, g1y, public_key[0], public_key[1], t[0], t[1], msg.sender)))"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        FunctionCall
           Type: uint256
           Source: "uint256(\n            keccak256(abi.encodePacked(g1x, g1y, public_key[0], public_key[1], t[0], t[1], msg.sender)))"
          ElementaryTypeNameExpression uint256
             Type: type(uint256)
             Source: "uint256"
          FunctionCall
             Type: bytes32
             Source: "keccak256(abi.encodePacked(g1x, g1y, public_key[0], public_key[1], t[0], t[1], msg.sender))"
            Identifier keccak256
               Type: function () pure returns (bytes32)
               Source: "keccak256"
            FunctionCall
               Type: bytes memory
               Source: "abi.encodePacked(g1x, g1y, public_key[0], public_key[1], t[0], t[1], msg.sender)"
              MemberAccess to member encodePacked
                 Type: function () pure returns (bytes memory)
                 Source: "abi.encodePacked"
                Identifier abi
                   Type: abi
                   Source: "abi"
              Identifier g1x
                 Type: uint256
                 Source: "g1x"
              Identifier g1y
                 Type: uint256
                 Source: "g1y"
              IndexAccess
                 Type: uint256
                 Source: "public_key[0]"
                Identifier public_key
                   Type: uint256[2] memory
                   Source: "public_key"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              IndexAccess
                 Type: uint256
                 Source: "public_key[1]"
                Identifier public_key
                   Type: uint256[2] memory
                   Source: "public_key"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
              IndexAccess
                 Type: uint256
                 Source: "t[0]"
                Identifier t
                   Type: uint256[2] memory
                   Source: "t"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              IndexAccess
                 Type: uint256
                 Source: "t[1]"
                Identifier t
                   Type: uint256[2] memory
                   Source: "t"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
      Return
         Source: "return proof[0] == c"
        BinaryOperation using operator ==
           Type: bool
           Source: "proof[0] == c"
          IndexAccess
             Type: uint256
             Source: "proof[0]"
            Identifier proof
               Type: uint256[2] memory
               Source: "proof"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          Identifier c
             Type: uint256
             Source: "c"
  FunctionDefinition "verify_decryption_key" - public
     Source: "function verify_decryption_key(\n        uint256[2] decryption_key, \n        uint256[2] correctness_proof, // DLEQ challenge and response      \n        uint256[2] verifier_pk,\n        uint256[2] issuer_pk) \n    public returns (bool key_valid)\n    {\n        // equivalent to DLEQ_verify(G1, issuer_pk, verifier_pk, decryption_key, correctness_proof) in python\n\n        uint256[2] memory tmp1;  // two temporary variables\n        uint256[2] memory tmp2;\n\n        tmp1 = bn128_multiply([g1x, g1y, correctness_proof[1]]);\n        tmp2 = bn128_multiply([verifier_pk[0], verifier_pk[1], correctness_proof[0]]);\n        uint256[2] memory a1 = bn128_add([tmp1[0], tmp1[1], tmp2[0], tmp2[1]]);\n        \n        tmp1 = bn128_multiply([issuer_pk[0], issuer_pk[1], correctness_proof[1]]);\n        tmp2 = bn128_multiply([decryption_key[0], decryption_key[1], correctness_proof[0]]);\n        uint256[2] memory a2 = bn128_add([tmp1[0], tmp1[1], tmp2[0], tmp2[1]]);\n\n        uint256 challenge_computed = uint256(\n            keccak256(abi.encodePacked(a1, a2, g1x, g1y, verifier_pk, issuer_pk, decryption_key)));\n\n        key_valid = correctness_proof[0] == challenge_computed;\n    }"
    ParameterList
       Source: "(\n        uint256[2] decryption_key, \n        uint256[2] correctness_proof, // DLEQ challenge and response      \n        uint256[2] verifier_pk,\n        uint256[2] issuer_pk)"
      VariableDeclaration "decryption_key"
         Type: uint256[2] memory
         Source: "uint256[2] decryption_key"
        ArrayTypeName
           Source: "uint256[2]"
          ElementaryTypeName uint256
             Source: "uint256"
          Literal, token: [no token] value: 2
             Type unknown.
             Source: "2"
      VariableDeclaration "correctness_proof"
         Type: uint256[2] memory
         Source: "uint256[2] correctness_proof"
        ArrayTypeName
           Source: "uint256[2]"
          ElementaryTypeName uint256
             Source: "uint256"
          Literal, token: [no token] value: 2
             Type unknown.
             Source: "2"
      VariableDeclaration "verifier_pk"
         Type: uint256[2] memory
         Source: "uint256[2] verifier_pk"
        ArrayTypeName
           Source: "uint256[2]"
          ElementaryTypeName uint256
             Source: "uint256"
          Literal, token: [no token] value: 2
             Type unknown.
             Source: "2"
      VariableDeclaration "issuer_pk"
         Type: uint256[2] memory
         Source: "uint256[2] issuer_pk"
        ArrayTypeName
           Source: "uint256[2]"
          ElementaryTypeName uint256
             Source: "uint256"
          Literal, token: [no token] value: 2
             Type unknown.
             Source: "2"
    ParameterList
       Source: "(bool key_valid)"
      VariableDeclaration "key_valid"
         Type: bool
         Source: "bool key_valid"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\n        // equivalent to DLEQ_verify(G1, issuer_pk, verifier_pk, decryption_key, correctness_proof) in python\n\n        uint256[2] memory tmp1;  // two temporary variables\n        uint256[2] memory tmp2;\n\n        tmp1 = bn128_multiply([g1x, g1y, correctness_proof[1]]);\n        tmp2 = bn128_multiply([verifier_pk[0], verifier_pk[1], correctness_proof[0]]);\n        uint256[2] memory a1 = bn128_add([tmp1[0], tmp1[1], tmp2[0], tmp2[1]]);\n        \n        tmp1 = bn128_multiply([issuer_pk[0], issuer_pk[1], correctness_proof[1]]);\n        tmp2 = bn128_multiply([decryption_key[0], decryption_key[1], correctness_proof[0]]);\n        uint256[2] memory a2 = bn128_add([tmp1[0], tmp1[1], tmp2[0], tmp2[1]]);\n\n        uint256 challenge_computed = uint256(\n            keccak256(abi.encodePacked(a1, a2, g1x, g1y, verifier_pk, issuer_pk, decryption_key)));\n\n        key_valid = correctness_proof[0] == challenge_computed;\n    }"
      VariableDeclarationStatement
         Source: "uint256[2] memory tmp1"
        VariableDeclaration "tmp1"
           Type: uint256[2] memory
           Source: "uint256[2] memory tmp1"
          ArrayTypeName
             Source: "uint256[2]"
            ElementaryTypeName uint256
               Source: "uint256"
            Literal, token: [no token] value: 2
               Type unknown.
               Source: "2"
      VariableDeclarationStatement
         Source: "uint256[2] memory tmp2"
        VariableDeclaration "tmp2"
           Type: uint256[2] memory
           Source: "uint256[2] memory tmp2"
          ArrayTypeName
             Source: "uint256[2]"
            ElementaryTypeName uint256
               Source: "uint256"
            Literal, token: [no token] value: 2
               Type unknown.
               Source: "2"
      ExpressionStatement
         Source: "tmp1 = bn128_multiply([g1x, g1y, correctness_proof[1]])"
        Assignment using operator =
           Type: uint256[2] memory
           Source: "tmp1 = bn128_multiply([g1x, g1y, correctness_proof[1]])"
          Identifier tmp1
             Type: uint256[2] memory
             Source: "tmp1"
          FunctionCall
             Type: uint256[2] memory
             Source: "bn128_multiply([g1x, g1y, correctness_proof[1]])"
            Identifier bn128_multiply
               Type: function (uint256[3] memory) returns (uint256[2] memory)
               Source: "bn128_multiply"
            TupleExpression
               Type: uint256[3] memory
               Source: "[g1x, g1y, correctness_proof[1]]"
              Identifier g1x
                 Type: uint256
                 Source: "g1x"
              Identifier g1y
                 Type: uint256
                 Source: "g1y"
              IndexAccess
                 Type: uint256
                 Source: "correctness_proof[1]"
                Identifier correctness_proof
                   Type: uint256[2] memory
                   Source: "correctness_proof"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
      ExpressionStatement
         Source: "tmp2 = bn128_multiply([verifier_pk[0], verifier_pk[1], correctness_proof[0]])"
        Assignment using operator =
           Type: uint256[2] memory
           Source: "tmp2 = bn128_multiply([verifier_pk[0], verifier_pk[1], correctness_proof[0]])"
          Identifier tmp2
             Type: uint256[2] memory
             Source: "tmp2"
          FunctionCall
             Type: uint256[2] memory
             Source: "bn128_multiply([verifier_pk[0], verifier_pk[1], correctness_proof[0]])"
            Identifier bn128_multiply
               Type: function (uint256[3] memory) returns (uint256[2] memory)
               Source: "bn128_multiply"
            TupleExpression
               Type: uint256[3] memory
               Source: "[verifier_pk[0], verifier_pk[1], correctness_proof[0]]"
              IndexAccess
                 Type: uint256
                 Source: "verifier_pk[0]"
                Identifier verifier_pk
                   Type: uint256[2] memory
                   Source: "verifier_pk"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              IndexAccess
                 Type: uint256
                 Source: "verifier_pk[1]"
                Identifier verifier_pk
                   Type: uint256[2] memory
                   Source: "verifier_pk"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
              IndexAccess
                 Type: uint256
                 Source: "correctness_proof[0]"
                Identifier correctness_proof
                   Type: uint256[2] memory
                   Source: "correctness_proof"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
      VariableDeclarationStatement
         Source: "uint256[2] memory a1 = bn128_add([tmp1[0], tmp1[1], tmp2[0], tmp2[1]])"
        VariableDeclaration "a1"
           Type: uint256[2] memory
           Source: "uint256[2] memory a1"
          ArrayTypeName
             Source: "uint256[2]"
            ElementaryTypeName uint256
               Source: "uint256"
            Literal, token: [no token] value: 2
               Type unknown.
               Source: "2"
        FunctionCall
           Type: uint256[2] memory
           Source: "bn128_add([tmp1[0], tmp1[1], tmp2[0], tmp2[1]])"
          Identifier bn128_add
             Type: function (uint256[4] memory) returns (uint256[2] memory)
             Source: "bn128_add"
          TupleExpression
             Type: uint256[4] memory
             Source: "[tmp1[0], tmp1[1], tmp2[0], tmp2[1]]"
            IndexAccess
               Type: uint256
               Source: "tmp1[0]"
              Identifier tmp1
                 Type: uint256[2] memory
                 Source: "tmp1"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            IndexAccess
               Type: uint256
               Source: "tmp1[1]"
              Identifier tmp1
                 Type: uint256[2] memory
                 Source: "tmp1"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
            IndexAccess
               Type: uint256
               Source: "tmp2[0]"
              Identifier tmp2
                 Type: uint256[2] memory
                 Source: "tmp2"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            IndexAccess
               Type: uint256
               Source: "tmp2[1]"
              Identifier tmp2
                 Type: uint256[2] memory
                 Source: "tmp2"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
      ExpressionStatement
         Source: "tmp1 = bn128_multiply([issuer_pk[0], issuer_pk[1], correctness_proof[1]])"
        Assignment using operator =
           Type: uint256[2] memory
           Source: "tmp1 = bn128_multiply([issuer_pk[0], issuer_pk[1], correctness_proof[1]])"
          Identifier tmp1
             Type: uint256[2] memory
             Source: "tmp1"
          FunctionCall
             Type: uint256[2] memory
             Source: "bn128_multiply([issuer_pk[0], issuer_pk[1], correctness_proof[1]])"
            Identifier bn128_multiply
               Type: function (uint256[3] memory) returns (uint256[2] memory)
               Source: "bn128_multiply"
            TupleExpression
               Type: uint256[3] memory
               Source: "[issuer_pk[0], issuer_pk[1], correctness_proof[1]]"
              IndexAccess
                 Type: uint256
                 Source: "issuer_pk[0]"
                Identifier issuer_pk
                   Type: uint256[2] memory
                   Source: "issuer_pk"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              IndexAccess
                 Type: uint256
                 Source: "issuer_pk[1]"
                Identifier issuer_pk
                   Type: uint256[2] memory
                   Source: "issuer_pk"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
              IndexAccess
                 Type: uint256
                 Source: "correctness_proof[1]"
                Identifier correctness_proof
                   Type: uint256[2] memory
                   Source: "correctness_proof"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
      ExpressionStatement
         Source: "tmp2 = bn128_multiply([decryption_key[0], decryption_key[1], correctness_proof[0]])"
        Assignment using operator =
           Type: uint256[2] memory
           Source: "tmp2 = bn128_multiply([decryption_key[0], decryption_key[1], correctness_proof[0]])"
          Identifier tmp2
             Type: uint256[2] memory
             Source: "tmp2"
          FunctionCall
             Type: uint256[2] memory
             Source: "bn128_multiply([decryption_key[0], decryption_key[1], correctness_proof[0]])"
            Identifier bn128_multiply
               Type: function (uint256[3] memory) returns (uint256[2] memory)
               Source: "bn128_multiply"
            TupleExpression
               Type: uint256[3] memory
               Source: "[decryption_key[0], decryption_key[1], correctness_proof[0]]"
              IndexAccess
                 Type: uint256
                 Source: "decryption_key[0]"
                Identifier decryption_key
                   Type: uint256[2] memory
                   Source: "decryption_key"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              IndexAccess
                 Type: uint256
                 Source: "decryption_key[1]"
                Identifier decryption_key
                   Type: uint256[2] memory
                   Source: "decryption_key"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
              IndexAccess
                 Type: uint256
                 Source: "correctness_proof[0]"
                Identifier correctness_proof
                   Type: uint256[2] memory
                   Source: "correctness_proof"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
      VariableDeclarationStatement
         Source: "uint256[2] memory a2 = bn128_add([tmp1[0], tmp1[1], tmp2[0], tmp2[1]])"
        VariableDeclaration "a2"
           Type: uint256[2] memory
           Source: "uint256[2] memory a2"
          ArrayTypeName
             Source: "uint256[2]"
            ElementaryTypeName uint256
               Source: "uint256"
            Literal, token: [no token] value: 2
               Type unknown.
               Source: "2"
        FunctionCall
           Type: uint256[2] memory
           Source: "bn128_add([tmp1[0], tmp1[1], tmp2[0], tmp2[1]])"
          Identifier bn128_add
             Type: function (uint256[4] memory) returns (uint256[2] memory)
             Source: "bn128_add"
          TupleExpression
             Type: uint256[4] memory
             Source: "[tmp1[0], tmp1[1], tmp2[0], tmp2[1]]"
            IndexAccess
               Type: uint256
               Source: "tmp1[0]"
              Identifier tmp1
                 Type: uint256[2] memory
                 Source: "tmp1"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            IndexAccess
               Type: uint256
               Source: "tmp1[1]"
              Identifier tmp1
                 Type: uint256[2] memory
                 Source: "tmp1"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
            IndexAccess
               Type: uint256
               Source: "tmp2[0]"
              Identifier tmp2
                 Type: uint256[2] memory
                 Source: "tmp2"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            IndexAccess
               Type: uint256
               Source: "tmp2[1]"
              Identifier tmp2
                 Type: uint256[2] memory
                 Source: "tmp2"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
      VariableDeclarationStatement
         Source: "uint256 challenge_computed = uint256(\n            keccak256(abi.encodePacked(a1, a2, g1x, g1y, verifier_pk, issuer_pk, decryption_key)))"
        VariableDeclaration "challenge_computed"
           Type: uint256
           Source: "uint256 challenge_computed"
          ElementaryTypeName uint256
             Source: "uint256"
        FunctionCall
           Type: uint256
           Source: "uint256(\n            keccak256(abi.encodePacked(a1, a2, g1x, g1y, verifier_pk, issuer_pk, decryption_key)))"
          ElementaryTypeNameExpression uint256
             Type: type(uint256)
             Source: "uint256"
          FunctionCall
             Type: bytes32
             Source: "keccak256(abi.encodePacked(a1, a2, g1x, g1y, verifier_pk, issuer_pk, decryption_key))"
            Identifier keccak256
               Type: function () pure returns (bytes32)
               Source: "keccak256"
            FunctionCall
               Type: bytes memory
               Source: "abi.encodePacked(a1, a2, g1x, g1y, verifier_pk, issuer_pk, decryption_key)"
              MemberAccess to member encodePacked
                 Type: function () pure returns (bytes memory)
                 Source: "abi.encodePacked"
                Identifier abi
                   Type: abi
                   Source: "abi"
              Identifier a1
                 Type: uint256[2] memory
                 Source: "a1"
              Identifier a2
                 Type: uint256[2] memory
                 Source: "a2"
              Identifier g1x
                 Type: uint256
                 Source: "g1x"
              Identifier g1y
                 Type: uint256
                 Source: "g1y"
              Identifier verifier_pk
                 Type: uint256[2] memory
                 Source: "verifier_pk"
              Identifier issuer_pk
                 Type: uint256[2] memory
                 Source: "issuer_pk"
              Identifier decryption_key
                 Type: uint256[2] memory
                 Source: "decryption_key"
      ExpressionStatement
         Source: "key_valid = correctness_proof[0] == challenge_computed"
        Assignment using operator =
           Type: bool
           Source: "key_valid = correctness_proof[0] == challenge_computed"
          Identifier key_valid
             Type: bool
             Source: "key_valid"
          BinaryOperation using operator ==
             Type: bool
             Source: "correctness_proof[0] == challenge_computed"
            IndexAccess
               Type: uint256
               Source: "correctness_proof[0]"
              Identifier correctness_proof
                 Type: uint256[2] memory
                 Source: "correctness_proof"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            Identifier challenge_computed
               Type: uint256
               Source: "challenge_computed"
  FunctionDefinition "verify_signature" - public
     Source: "function verify_signature(uint256[4] bls_pk, bytes32 message, uint256[2] signature) \n    public returns (bool signature_valid)\n    {\n        uint[2] memory h = bn128_map_to_G1(message);\n        signature_valid = bn128_check_pairing(                                   \n            [                                                  \n                signature[0], signature[1],                                  \n                g2xx, g2xy, g2yx, g2yy,                        \n                h[0], h[1],                                      \n                bls_pk[0], bls_pk[1], bls_pk[2], bls_pk[3]\n            ]);\n    }"
    ParameterList
       Source: "(uint256[4] bls_pk, bytes32 message, uint256[2] signature)"
      VariableDeclaration "bls_pk"
         Type: uint256[4] memory
         Source: "uint256[4] bls_pk"
        ArrayTypeName
           Source: "uint256[4]"
          ElementaryTypeName uint256
             Source: "uint256"
          Literal, token: [no token] value: 4
             Type unknown.
             Source: "4"
      VariableDeclaration "message"
         Type: bytes32
         Source: "bytes32 message"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "signature"
         Type: uint256[2] memory
         Source: "uint256[2] signature"
        ArrayTypeName
           Source: "uint256[2]"
          ElementaryTypeName uint256
             Source: "uint256"
          Literal, token: [no token] value: 2
             Type unknown.
             Source: "2"
    ParameterList
       Source: "(bool signature_valid)"
      VariableDeclaration "signature_valid"
         Type: bool
         Source: "bool signature_valid"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\n        uint[2] memory h = bn128_map_to_G1(message);\n        signature_valid = bn128_check_pairing(                                   \n            [                                                  \n                signature[0], signature[1],                                  \n                g2xx, g2xy, g2yx, g2yy,                        \n                h[0], h[1],                                      \n                bls_pk[0], bls_pk[1], bls_pk[2], bls_pk[3]\n            ]);\n    }"
      VariableDeclarationStatement
         Source: "uint[2] memory h = bn128_map_to_G1(message)"
        VariableDeclaration "h"
           Type: uint256[2] memory
           Source: "uint[2] memory h"
          ArrayTypeName
             Source: "uint[2]"
            ElementaryTypeName uint
               Source: "uint"
            Literal, token: [no token] value: 2
               Type unknown.
               Source: "2"
        FunctionCall
           Type: uint256[2] memory
           Source: "bn128_map_to_G1(message)"
          Identifier bn128_map_to_G1
             Type: function (bytes32) returns (uint256[2] memory)
             Source: "bn128_map_to_G1"
          Identifier message
             Type: bytes32
             Source: "message"
      ExpressionStatement
         Source: "signature_valid = bn128_check_pairing(                                   \n            [                                                  \n                signature[0], signature[1],                                  \n                g2xx, g2xy, g2yx, g2yy,                        \n                h[0], h[1],                                      \n                bls_pk[0], bls_pk[1], bls_pk[2], bls_pk[3]\n            ])"
        Assignment using operator =
           Type: bool
           Source: "signature_valid = bn128_check_pairing(                                   \n            [                                                  \n                signature[0], signature[1],                                  \n                g2xx, g2xy, g2yx, g2yy,                        \n                h[0], h[1],                                      \n                bls_pk[0], bls_pk[1], bls_pk[2], bls_pk[3]\n            ])"
          Identifier signature_valid
             Type: bool
             Source: "signature_valid"
          FunctionCall
             Type: bool
             Source: "bn128_check_pairing(                                   \n            [                                                  \n                signature[0], signature[1],                                  \n                g2xx, g2xy, g2yx, g2yy,                        \n                h[0], h[1],                                      \n                bls_pk[0], bls_pk[1], bls_pk[2], bls_pk[3]\n            ])"
            Identifier bn128_check_pairing
               Type: function (uint256[12] memory) returns (bool)
               Source: "bn128_check_pairing"
            TupleExpression
               Type: uint256[12] memory
               Source: "[                                                  \n                signature[0], signature[1],                                  \n                g2xx, g2xy, g2yx, g2yy,                        \n                h[0], h[1],                                      \n                bls_pk[0], bls_pk[1], bls_pk[2], bls_pk[3]\n            ]"
              IndexAccess
                 Type: uint256
                 Source: "signature[0]"
                Identifier signature
                   Type: uint256[2] memory
                   Source: "signature"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              IndexAccess
                 Type: uint256
                 Source: "signature[1]"
                Identifier signature
                   Type: uint256[2] memory
                   Source: "signature"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
              Identifier g2xx
                 Type: uint256
                 Source: "g2xx"
              Identifier g2xy
                 Type: uint256
                 Source: "g2xy"
              Identifier g2yx
                 Type: uint256
                 Source: "g2yx"
              Identifier g2yy
                 Type: uint256
                 Source: "g2yy"
              IndexAccess
                 Type: uint256
                 Source: "h[0]"
                Identifier h
                   Type: uint256[2] memory
                   Source: "h"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              IndexAccess
                 Type: uint256
                 Source: "h[1]"
                Identifier h
                   Type: uint256[2] memory
                   Source: "h"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
              IndexAccess
                 Type: uint256
                 Source: "bls_pk[0]"
                Identifier bls_pk
                   Type: uint256[4] memory
                   Source: "bls_pk"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              IndexAccess
                 Type: uint256
                 Source: "bls_pk[1]"
                Identifier bls_pk
                   Type: uint256[4] memory
                   Source: "bls_pk"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
              IndexAccess
                 Type: uint256
                 Source: "bls_pk[2]"
                Identifier bls_pk
                   Type: uint256[4] memory
                   Source: "bls_pk"
                Literal, token: [no token] value: 2
                   Type: int_const 2
                   Source: "2"
              IndexAccess
                 Type: uint256
                 Source: "bls_pk[3]"
                Identifier bls_pk
                   Type: uint256[4] memory
                   Source: "bls_pk"
                Literal, token: [no token] value: 3
                   Type: int_const 3
                   Source: "3"
  FunctionDefinition "bn128_add" - public
     Source: "function bn128_add(uint256[4] input) \n    public returns (uint256[2] result) {\n        // computes P + Q \n        // input: 4 values of 256 bit each\n        //  *) x-coordinate of point P\n        //  *) y-coordinate of point P\n        //  *) x-coordinate of point Q\n        //  *) y-coordinate of point Q\n\n        bool success;\n        assembly {\n            // 0x06     id of precompiled bn256Add contract\n            // 0        number of ether to transfer\n            // 128      size of call parameters, i.e. 128 bytes total\n            // 64       size of call return value, i.e. 64 bytes / 512 bit for a BN256 curve point\n            success := call(not(0), 0x06, 0, input, 128, result, 64)\n        }\n        require(success, \"elliptic curve addition failed\");\n    }"
    ParameterList
       Source: "(uint256[4] input)"
      VariableDeclaration "input"
         Type: uint256[4] memory
         Source: "uint256[4] input"
        ArrayTypeName
           Source: "uint256[4]"
          ElementaryTypeName uint256
             Source: "uint256"
          Literal, token: [no token] value: 4
             Type unknown.
             Source: "4"
    ParameterList
       Source: "(uint256[2] result)"
      VariableDeclaration "result"
         Type: uint256[2] memory
         Source: "uint256[2] result"
        ArrayTypeName
           Source: "uint256[2]"
          ElementaryTypeName uint256
             Source: "uint256"
          Literal, token: [no token] value: 2
             Type unknown.
             Source: "2"
    Block
       Source: "{\n        // computes P + Q \n        // input: 4 values of 256 bit each\n        //  *) x-coordinate of point P\n        //  *) y-coordinate of point P\n        //  *) x-coordinate of point Q\n        //  *) y-coordinate of point Q\n\n        bool success;\n        assembly {\n            // 0x06     id of precompiled bn256Add contract\n            // 0        number of ether to transfer\n            // 128      size of call parameters, i.e. 128 bytes total\n            // 64       size of call return value, i.e. 64 bytes / 512 bit for a BN256 curve point\n            success := call(not(0), 0x06, 0, input, 128, result, 64)\n        }\n        require(success, \"elliptic curve addition failed\");\n    }"
      VariableDeclarationStatement
         Source: "bool success"
        VariableDeclaration "success"
           Type: bool
           Source: "bool success"
          ElementaryTypeName bool
             Source: "bool"
      InlineAssembly
         Source: "assembly {\n            // 0x06     id of precompiled bn256Add contract\n            // 0        number of ether to transfer\n            // 128      size of call parameters, i.e. 128 bytes total\n            // 64       size of call return value, i.e. 64 bytes / 512 bit for a BN256 curve point\n            success := call(not(0), 0x06, 0, input, 128, result, 64)\n        }\n        require"
      ExpressionStatement
         Source: "require(success, \"elliptic curve addition failed\")"
        FunctionCall
           Type: tuple()
           Source: "require(success, \"elliptic curve addition failed\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          Identifier success
             Type: bool
             Source: "success"
          Literal, token: [no token] value: elliptic curve addition failed
             Type: literal_string "elliptic curve addition failed"
             Source: "\"elliptic curve addition failed\""
  FunctionDefinition "bn128_multiply" - public
     Source: "function bn128_multiply(uint256[3] input) \n    public returns (uint256[2] result) {\n        // computes P*x \n        // input: 3 values of 256 bit each\n        //  *) x-coordinate of point P\n        //  *) y-coordinate of point P\n        //  *) scalar x\n\n        bool success;\n        assembly {\n            // 0x07     id of precompiled bn256ScalarMul contract\n            // 0        number of ether to transfer\n            // 96       size of call parameters, i.e. 96 bytes total (256 bit for x, 256 bit for y, 256 bit for scalar)\n            // 64       size of call return value, i.e. 64 bytes / 512 bit for a BN256 curve point\n            success := call(not(0), 0x07, 0, input, 96, result, 64)\n        }\n        require(success, \"elliptic curve multiplication failed\");\n    }"
    ParameterList
       Source: "(uint256[3] input)"
      VariableDeclaration "input"
         Type: uint256[3] memory
         Source: "uint256[3] input"
        ArrayTypeName
           Source: "uint256[3]"
          ElementaryTypeName uint256
             Source: "uint256"
          Literal, token: [no token] value: 3
             Type unknown.
             Source: "3"
    ParameterList
       Source: "(uint256[2] result)"
      VariableDeclaration "result"
         Type: uint256[2] memory
         Source: "uint256[2] result"
        ArrayTypeName
           Source: "uint256[2]"
          ElementaryTypeName uint256
             Source: "uint256"
          Literal, token: [no token] value: 2
             Type unknown.
             Source: "2"
    Block
       Source: "{\n        // computes P*x \n        // input: 3 values of 256 bit each\n        //  *) x-coordinate of point P\n        //  *) y-coordinate of point P\n        //  *) scalar x\n\n        bool success;\n        assembly {\n            // 0x07     id of precompiled bn256ScalarMul contract\n            // 0        number of ether to transfer\n            // 96       size of call parameters, i.e. 96 bytes total (256 bit for x, 256 bit for y, 256 bit for scalar)\n            // 64       size of call return value, i.e. 64 bytes / 512 bit for a BN256 curve point\n            success := call(not(0), 0x07, 0, input, 96, result, 64)\n        }\n        require(success, \"elliptic curve multiplication failed\");\n    }"
      VariableDeclarationStatement
         Source: "bool success"
        VariableDeclaration "success"
           Type: bool
           Source: "bool success"
          ElementaryTypeName bool
             Source: "bool"
      InlineAssembly
         Source: "assembly {\n            // 0x07     id of precompiled bn256ScalarMul contract\n            // 0        number of ether to transfer\n            // 96       size of call parameters, i.e. 96 bytes total (256 bit for x, 256 bit for y, 256 bit for scalar)\n            // 64       size of call return value, i.e. 64 bytes / 512 bit for a BN256 curve point\n            success := call(not(0), 0x07, 0, input, 96, result, 64)\n        }\n        require"
      ExpressionStatement
         Source: "require(success, \"elliptic curve multiplication failed\")"
        FunctionCall
           Type: tuple()
           Source: "require(success, \"elliptic curve multiplication failed\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          Identifier success
             Type: bool
             Source: "success"
          Literal, token: [no token] value: elliptic curve multiplication failed
             Type: literal_string "elliptic curve multiplication failed"
             Source: "\"elliptic curve multiplication failed\""
  FunctionDefinition "bn128_is_on_curve" - public
     Source: "function bn128_is_on_curve(uint[2] point) \n    public returns(bool valid) {\n        // checks if the given point is a valid point from the first elliptic curve group\n        // by trying an addition with the generator point g1\n        uint256[4] memory input = [point[0], point[1], g1x, g1y];\n        assembly {\n            // 0x06     id of precompiled bn256Add contract\n            // 0        number of ether to transfer\n            // 128      size of call parameters, i.e. 128 bytes total\n            // 64       size of call return value, i.e. 64 bytes / 512 bit for a BN256 curve point\n            valid := call(not(0), 0x06, 0, input, 128, input, 64)\n        }\n    }"
    ParameterList
       Source: "(uint[2] point)"
      VariableDeclaration "point"
         Type: uint256[2] memory
         Source: "uint[2] point"
        ArrayTypeName
           Source: "uint[2]"
          ElementaryTypeName uint
             Source: "uint"
          Literal, token: [no token] value: 2
             Type unknown.
             Source: "2"
    ParameterList
       Source: "(bool valid)"
      VariableDeclaration "valid"
         Type: bool
         Source: "bool valid"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\n        // checks if the given point is a valid point from the first elliptic curve group\n        // by trying an addition with the generator point g1\n        uint256[4] memory input = [point[0], point[1], g1x, g1y];\n        assembly {\n            // 0x06     id of precompiled bn256Add contract\n            // 0        number of ether to transfer\n            // 128      size of call parameters, i.e. 128 bytes total\n            // 64       size of call return value, i.e. 64 bytes / 512 bit for a BN256 curve point\n            valid := call(not(0), 0x06, 0, input, 128, input, 64)\n        }\n    }"
      VariableDeclarationStatement
         Source: "uint256[4] memory input = [point[0], point[1], g1x, g1y]"
        VariableDeclaration "input"
           Type: uint256[4] memory
           Source: "uint256[4] memory input"
          ArrayTypeName
             Source: "uint256[4]"
            ElementaryTypeName uint256
               Source: "uint256"
            Literal, token: [no token] value: 4
               Type unknown.
               Source: "4"
        TupleExpression
           Type: uint256[4] memory
           Source: "[point[0], point[1], g1x, g1y]"
          IndexAccess
             Type: uint256
             Source: "point[0]"
            Identifier point
               Type: uint256[2] memory
               Source: "point"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          IndexAccess
             Type: uint256
             Source: "point[1]"
            Identifier point
               Type: uint256[2] memory
               Source: "point"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
          Identifier g1x
             Type: uint256
             Source: "g1x"
          Identifier g1y
             Type: uint256
             Source: "g1y"
      InlineAssembly
         Source: "assembly {\n            // 0x06     id of precompiled bn256Add contract\n            // 0        number of ether to transfer\n            // 128      size of call parameters, i.e. 128 bytes total\n            // 64       size of call return value, i.e. 64 bytes / 512 bit for a BN256 curve point\n            valid := call(not(0), 0x06, 0, input, 128, input, 64)\n        }\n    }"
  FunctionDefinition "bn128_check_pairing" - public
     Source: "function bn128_check_pairing(uint256[12] input) \n    public returns (bool) {\n        uint256[1] memory result;\n        bool success;\n        assembly {\n            // 0x08     id of precompiled bn256Pairing contract     (checking the elliptic curve pairings)\n            // 0        number of ether to transfer\n            // 384       size of call parameters, i.e. 12*256 bits == 384 bytes\n            // 32        size of result (one 32 byte boolean!)\n            success := call(sub(gas, 2000), 0x08, 0, input, 384, result, 32)\n        }\n        require(success, \"elliptic curve pairing failed\");\n        return result[0] == 1;\n    }"
    ParameterList
       Source: "(uint256[12] input)"
      VariableDeclaration "input"
         Type: uint256[12] memory
         Source: "uint256[12] input"
        ArrayTypeName
           Source: "uint256[12]"
          ElementaryTypeName uint256
             Source: "uint256"
          Literal, token: [no token] value: 12
             Type unknown.
             Source: "12"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\n        uint256[1] memory result;\n        bool success;\n        assembly {\n            // 0x08     id of precompiled bn256Pairing contract     (checking the elliptic curve pairings)\n            // 0        number of ether to transfer\n            // 384       size of call parameters, i.e. 12*256 bits == 384 bytes\n            // 32        size of result (one 32 byte boolean!)\n            success := call(sub(gas, 2000), 0x08, 0, input, 384, result, 32)\n        }\n        require(success, \"elliptic curve pairing failed\");\n        return result[0] == 1;\n    }"
      VariableDeclarationStatement
         Source: "uint256[1] memory result"
        VariableDeclaration "result"
           Type: uint256[1] memory
           Source: "uint256[1] memory result"
          ArrayTypeName
             Source: "uint256[1]"
            ElementaryTypeName uint256
               Source: "uint256"
            Literal, token: [no token] value: 1
               Type unknown.
               Source: "1"
      VariableDeclarationStatement
         Source: "bool success"
        VariableDeclaration "success"
           Type: bool
           Source: "bool success"
          ElementaryTypeName bool
             Source: "bool"
      InlineAssembly
         Source: "assembly {\n            // 0x08     id of precompiled bn256Pairing contract     (checking the elliptic curve pairings)\n            // 0        number of ether to transfer\n            // 384       size of call parameters, i.e. 12*256 bits == 384 bytes\n            // 32        size of result (one 32 byte boolean!)\n            success := call(sub(gas, 2000), 0x08, 0, input, 384, result, 32)\n        }\n        require"
      ExpressionStatement
         Source: "require(success, \"elliptic curve pairing failed\")"
        FunctionCall
           Type: tuple()
           Source: "require(success, \"elliptic curve pairing failed\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          Identifier success
             Type: bool
             Source: "success"
          Literal, token: [no token] value: elliptic curve pairing failed
             Type: literal_string "elliptic curve pairing failed"
             Source: "\"elliptic curve pairing failed\""
      Return
         Source: "return result[0] == 1"
        BinaryOperation using operator ==
           Type: bool
           Source: "result[0] == 1"
          IndexAccess
             Type: uint256
             Source: "result[0]"
            Identifier result
               Type: uint256[1] memory
               Source: "result"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
  FunctionDefinition "bn128_map_to_G1" - public
     Source: "function bn128_map_to_G1(bytes32 data)\n    public returns (uint[2] point) \n    {\n        uint256 ctr = 0;\n        while (true) {\n            uint256 x = uint256(keccak256(abi.encodePacked(ctr, data)));\n            bool b = x & 1 == 1;    // extract last bit of the hash\n            x >>= 2;                // drop last 2 bits of the hash, a coordinate is a 254 bit number\n\n            if (x < FIELD_MODULUS) { \n                // p...  FIELD_MODULUS\n                // z = x**3 + 3 (mod p)\n                uint256 z = (bigModExp([32, 32, 32, x, 3, FIELD_MODULUS]) + 3) % FIELD_MODULUS; \n\n                // y = sqrt(z) = z**((p + 1) / 4) mod p\n                uint256 y = bigModExp([32, 32, 32, z, (FIELD_MODULUS + 1) >> 2, FIELD_MODULUS]);\n\n                // checks if y is indeed a square root of z mod p\n                if (bigModExp([32, 32, 32, y, 2, FIELD_MODULUS]) == z) {\n                    if (b) {\n                        y = (FIELD_MODULUS - y);\n                    }\n                    return [x, y]; \n                }\n            }\n            ctr++;\n        }    \n    }"
    ParameterList
       Source: "(bytes32 data)"
      VariableDeclaration "data"
         Type: bytes32
         Source: "bytes32 data"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Source: "(uint[2] point)"
      VariableDeclaration "point"
         Type: uint256[2] memory
         Source: "uint[2] point"
        ArrayTypeName
           Source: "uint[2]"
          ElementaryTypeName uint
             Source: "uint"
          Literal, token: [no token] value: 2
             Type unknown.
             Source: "2"
    Block
       Source: "{\n        uint256 ctr = 0;\n        while (true) {\n            uint256 x = uint256(keccak256(abi.encodePacked(ctr, data)));\n            bool b = x & 1 == 1;    // extract last bit of the hash\n            x >>= 2;                // drop last 2 bits of the hash, a coordinate is a 254 bit number\n\n            if (x < FIELD_MODULUS) { \n                // p...  FIELD_MODULUS\n                // z = x**3 + 3 (mod p)\n                uint256 z = (bigModExp([32, 32, 32, x, 3, FIELD_MODULUS]) + 3) % FIELD_MODULUS; \n\n                // y = sqrt(z) = z**((p + 1) / 4) mod p\n                uint256 y = bigModExp([32, 32, 32, z, (FIELD_MODULUS + 1) >> 2, FIELD_MODULUS]);\n\n                // checks if y is indeed a square root of z mod p\n                if (bigModExp([32, 32, 32, y, 2, FIELD_MODULUS]) == z) {\n                    if (b) {\n                        y = (FIELD_MODULUS - y);\n                    }\n                    return [x, y]; \n                }\n            }\n            ctr++;\n        }    \n    }"
      VariableDeclarationStatement
         Source: "uint256 ctr = 0"
        VariableDeclaration "ctr"
           Type: uint256
           Source: "uint256 ctr"
          ElementaryTypeName uint256
             Source: "uint256"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      WhileStatement
         Source: "while (true) {\n            uint256 x = uint256(keccak256(abi.encodePacked(ctr, data)));\n            bool b = x & 1 == 1;    // extract last bit of the hash\n            x >>= 2;                // drop last 2 bits of the hash, a coordinate is a 254 bit number\n\n            if (x < FIELD_MODULUS) { \n                // p...  FIELD_MODULUS\n                // z = x**3 + 3 (mod p)\n                uint256 z = (bigModExp([32, 32, 32, x, 3, FIELD_MODULUS]) + 3) % FIELD_MODULUS; \n\n                // y = sqrt(z) = z**((p + 1) / 4) mod p\n                uint256 y = bigModExp([32, 32, 32, z, (FIELD_MODULUS + 1) >> 2, FIELD_MODULUS]);\n\n                // checks if y is indeed a square root of z mod p\n                if (bigModExp([32, 32, 32, y, 2, FIELD_MODULUS]) == z) {\n                    if (b) {\n                        y = (FIELD_MODULUS - y);\n                    }\n                    return [x, y]; \n                }\n            }\n            ctr++;\n        }"
        Literal, token: true value: true
           Type: bool
           Source: "true"
        Block
           Source: "{\n            uint256 x = uint256(keccak256(abi.encodePacked(ctr, data)));\n            bool b = x & 1 == 1;    // extract last bit of the hash\n            x >>= 2;                // drop last 2 bits of the hash, a coordinate is a 254 bit number\n\n            if (x < FIELD_MODULUS) { \n                // p...  FIELD_MODULUS\n                // z = x**3 + 3 (mod p)\n                uint256 z = (bigModExp([32, 32, 32, x, 3, FIELD_MODULUS]) + 3) % FIELD_MODULUS; \n\n                // y = sqrt(z) = z**((p + 1) / 4) mod p\n                uint256 y = bigModExp([32, 32, 32, z, (FIELD_MODULUS + 1) >> 2, FIELD_MODULUS]);\n\n                // checks if y is indeed a square root of z mod p\n                if (bigModExp([32, 32, 32, y, 2, FIELD_MODULUS]) == z) {\n                    if (b) {\n                        y = (FIELD_MODULUS - y);\n                    }\n                    return [x, y]; \n                }\n            }\n            ctr++;\n        }"
          VariableDeclarationStatement
             Source: "uint256 x = uint256(keccak256(abi.encodePacked(ctr, data)))"
            VariableDeclaration "x"
               Type: uint256
               Source: "uint256 x"
              ElementaryTypeName uint256
                 Source: "uint256"
            FunctionCall
               Type: uint256
               Source: "uint256(keccak256(abi.encodePacked(ctr, data)))"
              ElementaryTypeNameExpression uint256
                 Type: type(uint256)
                 Source: "uint256"
              FunctionCall
                 Type: bytes32
                 Source: "keccak256(abi.encodePacked(ctr, data))"
                Identifier keccak256
                   Type: function () pure returns (bytes32)
                   Source: "keccak256"
                FunctionCall
                   Type: bytes memory
                   Source: "abi.encodePacked(ctr, data)"
                  MemberAccess to member encodePacked
                     Type: function () pure returns (bytes memory)
                     Source: "abi.encodePacked"
                    Identifier abi
                       Type: abi
                       Source: "abi"
                  Identifier ctr
                     Type: uint256
                     Source: "ctr"
                  Identifier data
                     Type: bytes32
                     Source: "data"
          VariableDeclarationStatement
             Source: "bool b = x & 1 == 1"
            VariableDeclaration "b"
               Type: bool
               Source: "bool b"
              ElementaryTypeName bool
                 Source: "bool"
            BinaryOperation using operator ==
               Type: bool
               Source: "x & 1 == 1"
              BinaryOperation using operator &
                 Type: uint256
                 Source: "x & 1"
                Identifier x
                   Type: uint256
                   Source: "x"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
          ExpressionStatement
             Source: "x >>= 2"
            Assignment using operator >>=
               Type: uint256
               Source: "x >>= 2"
              Identifier x
                 Type: uint256
                 Source: "x"
              Literal, token: [no token] value: 2
                 Type: int_const 2
                 Source: "2"
          IfStatement
             Source: "if (x < FIELD_MODULUS) { \n                // p...  FIELD_MODULUS\n                // z = x**3 + 3 (mod p)\n                uint256 z = (bigModExp([32, 32, 32, x, 3, FIELD_MODULUS]) + 3) % FIELD_MODULUS; \n\n                // y = sqrt(z) = z**((p + 1) / 4) mod p\n                uint256 y = bigModExp([32, 32, 32, z, (FIELD_MODULUS + 1) >> 2, FIELD_MODULUS]);\n\n                // checks if y is indeed a square root of z mod p\n                if (bigModExp([32, 32, 32, y, 2, FIELD_MODULUS]) == z) {\n                    if (b) {\n                        y = (FIELD_MODULUS - y);\n                    }\n                    return [x, y]; \n                }\n            }"
            BinaryOperation using operator <
               Type: bool
               Source: "x < FIELD_MODULUS"
              Identifier x
                 Type: uint256
                 Source: "x"
              Identifier FIELD_MODULUS
                 Type: uint256
                 Source: "FIELD_MODULUS"
            Block
               Source: "{ \n                // p...  FIELD_MODULUS\n                // z = x**3 + 3 (mod p)\n                uint256 z = (bigModExp([32, 32, 32, x, 3, FIELD_MODULUS]) + 3) % FIELD_MODULUS; \n\n                // y = sqrt(z) = z**((p + 1) / 4) mod p\n                uint256 y = bigModExp([32, 32, 32, z, (FIELD_MODULUS + 1) >> 2, FIELD_MODULUS]);\n\n                // checks if y is indeed a square root of z mod p\n                if (bigModExp([32, 32, 32, y, 2, FIELD_MODULUS]) == z) {\n                    if (b) {\n                        y = (FIELD_MODULUS - y);\n                    }\n                    return [x, y]; \n                }\n            }"
              VariableDeclarationStatement
                 Source: "uint256 z = (bigModExp([32, 32, 32, x, 3, FIELD_MODULUS]) + 3) % FIELD_MODULUS"
                VariableDeclaration "z"
                   Type: uint256
                   Source: "uint256 z"
                  ElementaryTypeName uint256
                     Source: "uint256"
                BinaryOperation using operator %
                   Type: uint256
                   Source: "(bigModExp([32, 32, 32, x, 3, FIELD_MODULUS]) + 3) % FIELD_MODULUS"
                  TupleExpression
                     Type: uint256
                     Source: "(bigModExp([32, 32, 32, x, 3, FIELD_MODULUS]) + 3)"
                    BinaryOperation using operator +
                       Type: uint256
                       Source: "bigModExp([32, 32, 32, x, 3, FIELD_MODULUS]) + 3"
                      FunctionCall
                         Type: uint256
                         Source: "bigModExp([32, 32, 32, x, 3, FIELD_MODULUS])"
                        Identifier bigModExp
                           Type: function (uint256[6] memory) returns (uint256)
                           Source: "bigModExp"
                        TupleExpression
                           Type: uint256[6] memory
                           Source: "[32, 32, 32, x, 3, FIELD_MODULUS]"
                          Literal, token: [no token] value: 32
                             Type: int_const 32
                             Source: "32"
                          Literal, token: [no token] value: 32
                             Type: int_const 32
                             Source: "32"
                          Literal, token: [no token] value: 32
                             Type: int_const 32
                             Source: "32"
                          Identifier x
                             Type: uint256
                             Source: "x"
                          Literal, token: [no token] value: 3
                             Type: int_const 3
                             Source: "3"
                          Identifier FIELD_MODULUS
                             Type: uint256
                             Source: "FIELD_MODULUS"
                      Literal, token: [no token] value: 3
                         Type: int_const 3
                         Source: "3"
                  Identifier FIELD_MODULUS
                     Type: uint256
                     Source: "FIELD_MODULUS"
              VariableDeclarationStatement
                 Source: "uint256 y = bigModExp([32, 32, 32, z, (FIELD_MODULUS + 1) >> 2, FIELD_MODULUS])"
                VariableDeclaration "y"
                   Type: uint256
                   Source: "uint256 y"
                  ElementaryTypeName uint256
                     Source: "uint256"
                FunctionCall
                   Type: uint256
                   Source: "bigModExp([32, 32, 32, z, (FIELD_MODULUS + 1) >> 2, FIELD_MODULUS])"
                  Identifier bigModExp
                     Type: function (uint256[6] memory) returns (uint256)
                     Source: "bigModExp"
                  TupleExpression
                     Type: uint256[6] memory
                     Source: "[32, 32, 32, z, (FIELD_MODULUS + 1) >> 2, FIELD_MODULUS]"
                    Literal, token: [no token] value: 32
                       Type: int_const 32
                       Source: "32"
                    Literal, token: [no token] value: 32
                       Type: int_const 32
                       Source: "32"
                    Literal, token: [no token] value: 32
                       Type: int_const 32
                       Source: "32"
                    Identifier z
                       Type: uint256
                       Source: "z"
                    BinaryOperation using operator >>
                       Type: uint256
                       Source: "(FIELD_MODULUS + 1) >> 2"
                      TupleExpression
                         Type: uint256
                         Source: "(FIELD_MODULUS + 1)"
                        BinaryOperation using operator +
                           Type: uint256
                           Source: "FIELD_MODULUS + 1"
                          Identifier FIELD_MODULUS
                             Type: uint256
                             Source: "FIELD_MODULUS"
                          Literal, token: [no token] value: 1
                             Type: int_const 1
                             Source: "1"
                      Literal, token: [no token] value: 2
                         Type: int_const 2
                         Source: "2"
                    Identifier FIELD_MODULUS
                       Type: uint256
                       Source: "FIELD_MODULUS"
              IfStatement
                 Source: "if (bigModExp([32, 32, 32, y, 2, FIELD_MODULUS]) == z) {\n                    if (b) {\n                        y = (FIELD_MODULUS - y);\n                    }\n                    return [x, y]; \n                }"
                BinaryOperation using operator ==
                   Type: bool
                   Source: "bigModExp([32, 32, 32, y, 2, FIELD_MODULUS]) == z"
                  FunctionCall
                     Type: uint256
                     Source: "bigModExp([32, 32, 32, y, 2, FIELD_MODULUS])"
                    Identifier bigModExp
                       Type: function (uint256[6] memory) returns (uint256)
                       Source: "bigModExp"
                    TupleExpression
                       Type: uint256[6] memory
                       Source: "[32, 32, 32, y, 2, FIELD_MODULUS]"
                      Literal, token: [no token] value: 32
                         Type: int_const 32
                         Source: "32"
                      Literal, token: [no token] value: 32
                         Type: int_const 32
                         Source: "32"
                      Literal, token: [no token] value: 32
                         Type: int_const 32
                         Source: "32"
                      Identifier y
                         Type: uint256
                         Source: "y"
                      Literal, token: [no token] value: 2
                         Type: int_const 2
                         Source: "2"
                      Identifier FIELD_MODULUS
                         Type: uint256
                         Source: "FIELD_MODULUS"
                  Identifier z
                     Type: uint256
                     Source: "z"
                Block
                   Source: "{\n                    if (b) {\n                        y = (FIELD_MODULUS - y);\n                    }\n                    return [x, y]; \n                }"
                  IfStatement
                     Source: "if (b) {\n                        y = (FIELD_MODULUS - y);\n                    }"
                    Identifier b
                       Type: bool
                       Source: "b"
                    Block
                       Source: "{\n                        y = (FIELD_MODULUS - y);\n                    }"
                      ExpressionStatement
                         Source: "y = (FIELD_MODULUS - y)"
                        Assignment using operator =
                           Type: uint256
                           Source: "y = (FIELD_MODULUS - y)"
                          Identifier y
                             Type: uint256
                             Source: "y"
                          TupleExpression
                             Type: uint256
                             Source: "(FIELD_MODULUS - y)"
                            BinaryOperation using operator -
                               Type: uint256
                               Source: "FIELD_MODULUS - y"
                              Identifier FIELD_MODULUS
                                 Type: uint256
                                 Source: "FIELD_MODULUS"
                              Identifier y
                                 Type: uint256
                                 Source: "y"
                  Return
                     Source: "return [x, y]"
                    TupleExpression
                       Type: uint256[2] memory
                       Source: "[x, y]"
                      Identifier x
                         Type: uint256
                         Source: "x"
                      Identifier y
                         Type: uint256
                         Source: "y"
          ExpressionStatement
             Source: "ctr++"
            UnaryOperation (postfix) ++
               Type: uint256
               Source: "ctr++"
              Identifier ctr
                 Type: uint256
                 Source: "ctr"
  FunctionDefinition "bigModExp" - public
     Source: "function bigModExp(uint256[6] input) \n    public returns (uint256) {\n        // call the precompiled contract to compute the b^e mod m\n        // used the following arguments in the given order\n        //  - length of the base b\n        //  - length of the exponent e\n        //  - length of the modulus m\n        //  - the base b itself\n        //  - the exponent e itself\n        //  - the modulus m itself\n        // we use 256 bit integers for all of the above values\n\n        bool success;\n        uint256[1] memory result;\n        assembly {\n            // 0x05     id of precompiled bigModExp contract\n            // 0        number of ether to transfer\n            // 192      size of call parameters, i.e. 192 bytes total (6x 256 bit)\n            // 32       size of call return value, i.e. 32 bytes / 256 bit\n            success := call(not(0), 0x05, 0, input, 192, result, 32)\n        }\n        require(success, \"bigModExp operation failed\");\n        return result[0];\n    }"
    ParameterList
       Source: "(uint256[6] input)"
      VariableDeclaration "input"
         Type: uint256[6] memory
         Source: "uint256[6] input"
        ArrayTypeName
           Source: "uint256[6]"
          ElementaryTypeName uint256
             Source: "uint256"
          Literal, token: [no token] value: 6
             Type unknown.
             Source: "6"
    ParameterList
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\n        // call the precompiled contract to compute the b^e mod m\n        // used the following arguments in the given order\n        //  - length of the base b\n        //  - length of the exponent e\n        //  - length of the modulus m\n        //  - the base b itself\n        //  - the exponent e itself\n        //  - the modulus m itself\n        // we use 256 bit integers for all of the above values\n\n        bool success;\n        uint256[1] memory result;\n        assembly {\n            // 0x05     id of precompiled bigModExp contract\n            // 0        number of ether to transfer\n            // 192      size of call parameters, i.e. 192 bytes total (6x 256 bit)\n            // 32       size of call return value, i.e. 32 bytes / 256 bit\n            success := call(not(0), 0x05, 0, input, 192, result, 32)\n        }\n        require(success, \"bigModExp operation failed\");\n        return result[0];\n    }"
      VariableDeclarationStatement
         Source: "bool success"
        VariableDeclaration "success"
           Type: bool
           Source: "bool success"
          ElementaryTypeName bool
             Source: "bool"
      VariableDeclarationStatement
         Source: "uint256[1] memory result"
        VariableDeclaration "result"
           Type: uint256[1] memory
           Source: "uint256[1] memory result"
          ArrayTypeName
             Source: "uint256[1]"
            ElementaryTypeName uint256
               Source: "uint256"
            Literal, token: [no token] value: 1
               Type unknown.
               Source: "1"
      InlineAssembly
         Source: "assembly {\n            // 0x05     id of precompiled bigModExp contract\n            // 0        number of ether to transfer\n            // 192      size of call parameters, i.e. 192 bytes total (6x 256 bit)\n            // 32       size of call return value, i.e. 32 bytes / 256 bit\n            success := call(not(0), 0x05, 0, input, 192, result, 32)\n        }\n        require"
      ExpressionStatement
         Source: "require(success, \"bigModExp operation failed\")"
        FunctionCall
           Type: tuple()
           Source: "require(success, \"bigModExp operation failed\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          Identifier success
             Type: bool
             Source: "success"
          Literal, token: [no token] value: bigModExp operation failed
             Type: literal_string "bigModExp operation failed"
             Source: "\"bigModExp operation failed\""
      Return
         Source: "return result[0]"
        IndexAccess
           Type: uint256
           Source: "result[0]"
          Identifier result
             Type: uint256[1] memory
             Source: "result"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
